<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zero-Sum Defense</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, addDoc, updateDoc, writeBatch, query, where, getDocs, setLogLevel, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ==========================================
        // 1. CONFIGURATION & CONSTANTS
        // ==========================================
        const CONSTANTS = {
            BOARD_ROWS: 8,
            BOARD_COLS: 10,
            NEXUS_HP: 3,
            BUILDING_HP: 1,
            COST: { PYLON: 1, MIRROR: 1 },
            NEXUS_RANGE: 3,
            COLORS: ['Red', 'Yellow', 'Blue', 'Green', 'Purple', 'Orange', 'Pink', 'Cyan'],
            // ADDED 'text' property to map for the HUD
            COLOR_MAP: {
                'Red':    { bg: 'bg-red-900/20',    stroke: 'stroke-rose-400',   border: 'border-rose-400',   text: 'text-rose-400' },
                'Yellow': { bg: 'bg-yellow-900/20', stroke: 'stroke-yellow-400', border: 'border-yellow-400', text: 'text-yellow-400' },
                'Blue':   { bg: 'bg-blue-900/20',   stroke: 'stroke-blue-400',   border: 'border-blue-400',   text: 'text-blue-400' },
                'Green':  { bg: 'bg-green-900/20',  stroke: 'stroke-green-400',  border: 'border-green-400',  text: 'text-green-400' },
                'Purple': { bg: 'bg-purple-900/20', stroke: 'stroke-purple-400', border: 'border-purple-400', text: 'text-purple-400' },
                'Orange': { bg: 'bg-orange-900/20', stroke: 'stroke-orange-400', border: 'border-orange-400', text: 'text-orange-400' },
                'Pink':   { bg: 'bg-pink-900/20',   stroke: 'stroke-pink-400',   border: 'border-pink-400',   text: 'text-pink-400' },
                'Cyan':   { bg: 'bg-cyan-900/20',   stroke: 'stroke-cyan-400',   border: 'border-cyan-400',   text: 'text-cyan-400' }
            },
            VECTORS: {
                'fromN': "1,0",
                'fromNE': "1,-1",
                'fromE': "0,-1",
                'fromSE': "-1,-1",
                'fromS': "-1,0",
                'fromSW': "-1,1",
                'fromW': "0,1",
                'fromNW': "1,1",
                'toN': [-1, 0],
                'toNE': [-1,1],
                'toE': [0,1],
                'toSE': [1,1],
                'toS': [1,0],
                'toSW': [1,-1],
                'toW': [0,-1],
                'toNW': [-1,-1]
            },
            DIRECTIONS: {
                'N': [-1, 0], 'NE': [-1, 1], 'E': [0, 1], 'SE': [1, 1],
                'S': [1, 0], 'SW': [1, -1], 'W': [0, -1], 'NW': [-1, -1]
            },
            SVGS: {
                NEXUS: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path></svg>`,
                PYLON: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L7 22h10L12 2z"></path></svg>`,
                MIRROR_SHAPES: {
                    'N': `<path d="M0 18 L6 24 L18 24 L24 18 L24 15 L0 15 Z" />`,
                    'E': `<path d="M6 0 L0 6 L0 18 L6 24 L9 24 L9 0 Z" />`,
                    'S': `<path d="M0 6 L6 0 L18 0 L24 6 L24 9 L0 9 Z" />`,
                    'W': `<path d="M18 0 L24 6 L24 18 L18 24 L15 24 L15 0 Z" />`,
                    'NE': `<polygon points="0,0 0,24 24,24" />`,
                    'SE': `<polygon points="0,0 24,0 0,24" />`,
                    'SW': `<polygon points="0,0 24,0 24,24" />`,
                    'NW': `<polygon points="0,24 24,24 24,0" />`
                }
            },
            LASER_COLORS: {
                'Red':    '#ff0000',
                'Yellow': '#eab308',
                'Blue':   '#0000ff',
                'Green':  '#00ff00',
                'Purple': '#be00ff',
                'Orange': '#ff7f00',
                'Pink':   '#ff00bf',
                'Cyan':   '#00ffff'
            },
            APP_ID: typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'
        };
        CONSTANTS.REFLECTION_MAP = {
            'N': {
                [CONSTANTS.VECTORS.fromNW]: CONSTANTS.VECTORS.toNE,
                [CONSTANTS.VECTORS.fromN]: CONSTANTS.VECTORS.toN,
                [CONSTANTS.VECTORS.fromNE]: CONSTANTS.VECTORS.toNW,
                [CONSTANTS.VECTORS.fromE]: "DESTROY",
                [CONSTANTS.VECTORS.fromSE]: "DESTROY",
                [CONSTANTS.VECTORS.fromS]: "DESTROY",
                [CONSTANTS.VECTORS.fromSW]: "DESTROY",
                [CONSTANTS.VECTORS.fromW]: "DESTROY"
            },
            'NE': {
                [CONSTANTS.VECTORS.fromN]: CONSTANTS.VECTORS.toE,
                [CONSTANTS.VECTORS.fromNE]: CONSTANTS.VECTORS.toNE,
                [CONSTANTS.VECTORS.fromE]: CONSTANTS.VECTORS.toN,
                [CONSTANTS.VECTORS.fromSE]: "DESTROY",
                [CONSTANTS.VECTORS.fromS]: "DESTROY",
                [CONSTANTS.VECTORS.fromSW]: "DESTROY",
                [CONSTANTS.VECTORS.fromW]: "DESTROY",
                [CONSTANTS.VECTORS.fromNW]: "DESTROY"
            },
            'E': {
                [CONSTANTS.VECTORS.fromNE]: CONSTANTS.VECTORS.toSE,
                [CONSTANTS.VECTORS.fromE]: CONSTANTS.VECTORS.toE,
                [CONSTANTS.VECTORS.fromSE]: CONSTANTS.VECTORS.toNE,
                [CONSTANTS.VECTORS.fromS]: "DESTROY",
                [CONSTANTS.VECTORS.fromSW]: "DESTROY",
                [CONSTANTS.VECTORS.fromW]: "DESTROY",
                [CONSTANTS.VECTORS.fromNW]: "DESTROY",
                [CONSTANTS.VECTORS.fromN]: "DESTROY"
            },
            'SE': {
                [CONSTANTS.VECTORS.fromE]: CONSTANTS.VECTORS.toS,
                [CONSTANTS.VECTORS.fromSE]: CONSTANTS.VECTORS.toSE,
                [CONSTANTS.VECTORS.fromS]: CONSTANTS.VECTORS.toE,
                [CONSTANTS.VECTORS.fromSW]: "DESTROY",
                [CONSTANTS.VECTORS.fromW]: "DESTROY",
                [CONSTANTS.VECTORS.fromNW]: "DESTROY",
                [CONSTANTS.VECTORS.fromN]: "DESTROY",
                [CONSTANTS.VECTORS.fromNE]: "DESTROY",
            },
            'S': {
                [CONSTANTS.VECTORS.fromSE]: CONSTANTS.VECTORS.toSW,
                [CONSTANTS.VECTORS.fromS]: CONSTANTS.VECTORS.toS,
                [CONSTANTS.VECTORS.fromSW]: CONSTANTS.VECTORS.toSE,
                [CONSTANTS.VECTORS.fromW]: "DESTROY",
                [CONSTANTS.VECTORS.fromNW]: "DESTROY",
                [CONSTANTS.VECTORS.fromN]: "DESTROY",
                [CONSTANTS.VECTORS.fromNE]: "DESTROY",
                [CONSTANTS.VECTORS.fromE]: "DESTROY"
            },
            'SW': {
                [CONSTANTS.VECTORS.fromS]: CONSTANTS.VECTORS.toW,
                [CONSTANTS.VECTORS.fromSW]: CONSTANTS.VECTORS.toSW,
                [CONSTANTS.VECTORS.fromW]: CONSTANTS.VECTORS.toS,
                [CONSTANTS.VECTORS.fromNW]: "DESTROY",
                [CONSTANTS.VECTORS.fromN]: "DESTROY",
                [CONSTANTS.VECTORS.fromNE]: "DESTROY",
                [CONSTANTS.VECTORS.fromE]: "DESTROY",
                [CONSTANTS.VECTORS.fromSE]: "DESTROY"
            },
            'W': {
                [CONSTANTS.VECTORS.fromSW]: CONSTANTS.VECTORS.toNW,
                [CONSTANTS.VECTORS.fromW]: CONSTANTS.VECTORS.toW,
                [CONSTANTS.VECTORS.fromNW]: CONSTANTS.VECTORS.toSW,
                [CONSTANTS.VECTORS.fromN]: "DESTROY",
                [CONSTANTS.VECTORS.fromNE]: "DESTROY",
                [CONSTANTS.VECTORS.fromE]: "DESTROY",
                [CONSTANTS.VECTORS.fromSE]: "DESTROY",
                [CONSTANTS.VECTORS.fromS]: "DESTROY"
            },
            'NW': {
                [CONSTANTS.VECTORS.fromW]: CONSTANTS.VECTORS.toN,
                [CONSTANTS.VECTORS.fromNW]: CONSTANTS.VECTORS.toNW,
                [CONSTANTS.VECTORS.fromN]: CONSTANTS.VECTORS.toW,
                [CONSTANTS.VECTORS.fromNE]: "DESTROY",
                [CONSTANTS.VECTORS.fromE]: "DESTROY",
                [CONSTANTS.VECTORS.fromSE]: "DESTROY",
                [CONSTANTS.VECTORS.fromS]: "DESTROY",
                [CONSTANTS.VECTORS.fromSW]: "DESTROY"
            }
        }

        // ==========================================
        // 2. GLOBAL STATE
        // ==========================================
        const State = {
            db: null,
            auth: null,
            currentUser: null, // { uid, profile }
            gameId: null,
            game: null,       // The full game document
            playerIndex: -1,  // 0 or 1
            
            // Action State
            currentAction: null, // 'place-pylon', 'place-mirror', 'move-nexus-select', 'setup'
            selectedLocation: null, // [r, c] for nexus moves/setup
            currentMirrorOrientation: 'N',
            
            // Subscriptions (to unsubscribe later)
            subs: {
                game: null,
                online: null,
                invites: null
            }
        };

        // ==========================================
        // 3. DOM ELEMENTS (Cached)
        // ==========================================
        const DOM = {
            $: (s) => document.querySelector(s),
            $$: (s) => document.querySelectorAll(s),
            
            // Views
            views: {
                profile: document.querySelector('#profile-view'),
                lobby: document.querySelector('#lobby-view'),
                lobbyList: document.querySelector('#lobby-list-view'),
                createLobby: document.querySelector('#create-lobby-view'),
                waitingRoom: document.querySelector('#waiting-room-view'),
                game: document.querySelector('#game-view'),
                modal: document.querySelector('#modal-view')
            },
            
            // Inputs & Dynamic Areas
            lobbyListContainer: document.querySelector('#lobby-list-container'),
            onlineList: document.querySelector('#online-players-list'),
            gameBoard: document.querySelector('#game-board'),
            gameLog: document.querySelector('#game-log'),
            
            // Text Displays
            userId: document.querySelector('#user-id-display'),
            userName: document.querySelector('#user-display-name-display'),
            gameId: document.querySelector('#game-id-display'),
            playerNum: document.querySelector('#player-number'),
            turn: document.querySelector('#current-turn'),
            phase: document.querySelector('#current-phase'),
            energy: document.querySelector('#energy-pool'),
            budget: document.querySelector('#player-budget'),
            modalMsg: document.querySelector('#modal-message')
        };

        // ==========================================
        // 4. GAME LOGIC (Pure Functions)
        // ==========================================
        const GameLogic = {
            getUnitAt: (r, c, gameData) => {
                if (!gameData || !gameData.players) return null;
                for (let i = 0; i < gameData.players.length; i++) {
                    const p = gameData.players[i];
                    if (!p) continue;
                    // Check Nexus
                    if (p.nexusLocation && p.nexusLocation[0] === r && p.nexusLocation[1] === c) {
                        return { type: 'nexus', hp: p.nexusHP, ownerIdx: i };
                    }
                    // Check Buildings
                    const b = p.buildings.find(b => b.location[0] === r && b.location[1] === c);
                    if (b) return { ...b, ownerIdx: i };
                }
                return null;
            },

            isValidNexusMove: (startLoc, targetLoc, playerIndex, gameData) => {
                if (!startLoc || !targetLoc) return false;
                const p = gameData.players[playerIndex];
                // Use start-of-turn location for range check
                const [rS, cS] = p.nexusStartLoc || startLoc; 
                const [rT, cT] = targetLoc;
                
                const dist = Math.abs(rS - rT) + Math.abs(cS - cT);
                if (dist > CONSTANTS.NEXUS_RANGE) return false;

                const unit = GameLogic.getUnitAt(rT, cT, gameData);
                // Can only move to empty space or own nexus (self)
                if (unit && unit.type !== 'nexus') return false;
                if (unit && unit.type === 'nexus' && unit.ownerIdx !== playerIndex) return false;
                
                return true;
            },

            traceLaser: (startLoc, direction, gameData) => {
                let [r, c] = startLoc;
                let [dx, dy] = direction;
                let path = [[r, c]];
                let hits = [];
                let log = [];
                
                // Clone game state for simulation
                const simGame = JSON.parse(JSON.stringify(gameData)); 

                for (let i = 0; i < 40; i++) { // Max steps
                    r += dx; c += dy;
                    path.push([r, c]);

                    // 1. Wall Check
                    const rOut = r < 0 || r >= CONSTANTS.BOARD_ROWS;
                    const cOut = c < 0 || c >= CONSTANTS.BOARD_COLS;

                    // STOP if hitting Back Walls (Left/Right columns)
                    if (cOut) {
                        log.push("Laser escaped the system (Miss).");
                        break; 
                    }

                    // REFLECT if hitting Side Walls (Top/Bottom rows)
                    if (rOut) {
                        log.push("Laser reflected off side boundary.");
                        
                        const [prevR, prevC] = path[path.length - 2];
                        
                        r = prevR;
                        c = prevC + dy;
                        
                        path[path.length - 1] = [r, c]; 

                        const cOut = c < 0 || c >= CONSTANTS.BOARD_COLS;
                        if (cOut) {
                            log.push("Laser reflected into a corner and escaped (Miss).");
                            break; 
                        }

                        dx = -dx; 
                        direction = [dx, dy];
                    }

                    // 2. Unit Check
                    const unit = GameLogic.getUnitAt(r, c, simGame);
                    if (unit) {
                        const ownerName = simGame.players[unit.ownerIdx].displayName;
                        if (unit.type === 'nexus') {
                            log.push(`HIT ${ownerName}'s Nexus!`);
                            hits.push(unit);
                            unit.hp--;
                            break; 
                        } else if (unit.type === 'pylon') {
                            log.push(`HIT ${ownerName}'s Pylon!`);
                            hits.push(unit);
                            break;
                        } else if (unit.type === 'mirror') {
                            const orientation = unit.orientation || 'N';
                            const incomingVecKey = `${dx},${dy}`;
                            const ruleSet = CONSTANTS.REFLECTION_MAP[orientation];
                            if (!ruleSet || !ruleSet[incomingVecKey]) {
                                log.push(`ERROR: Mirror ${orientation} has no rule for ${incomingVecKey}!`);
                                break;
                            }
                            const result = ruleSet[incomingVecKey];
                            if (result === 'DESTROY') {
                                log.push(`HIT ${ownerName}'s Mirror!`);
                                hits.push(unit);
                                break; 
                            } else {
                                log.push(`REFLECT off ${ownerName}'s Mirror!`);
                                [dx, dy] = result;
                                direction = [dx, dy];
                                continue;
                            }
                        }
                    }
                }
                return { path, hits, log };
            }
        };

        // ==========================================
        // 5. API LAYER (Firebase Interactions)
        // ==========================================
        const API = {
            init: async () => {
                const config = {
                    apiKey: "AIzaSyBTK04oSfdM5K0w8sspYn42OQzCGFf8AMM",
                    authDomain: "zero-sum-defense.firebaseapp.com",
                    projectId: "zero-sum-defense",
                    storageBucket: "zero-sum-defense.firebasestorage.app",
                    messagingSenderId: "484724724929",
                    appId: "1:484724724929:web:104009b0c91ee8559a3040"
                };
                const app = initializeApp(config);
                State.db = getFirestore(app);
                State.auth = getAuth(app);
                setLogLevel('error'); // Clean console

                onAuthStateChanged(State.auth, async (user) => {
                    if (user) {
                        State.currentUser = { uid: user.uid };
                        DOM.userId.textContent = user.uid;
                        await API.loadProfile();
                        API.presence.start();
                        API.presence.listenInvites();
                    } else {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            signInWithCustomToken(State.auth, __initial_auth_token);
                        } else {
                            signInAnonymously(State.auth);
                        }
                    }
                });
            },

            loadProfile: async () => {
                try {
                    const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'users', State.currentUser.uid, 'profile', 'settings');
                    const snap = await getDoc(ref);
                    if (snap.exists()) {
                        State.currentUser.profile = snap.data();
                        DOM.userName.textContent = State.currentUser.profile.displayName;
                        UIManager.show('lobby');
                    } else {
                        UIManager.populateColors(DOM.$('#profile-color-select'));
                        UIManager.show('profile');
                    }
                } catch(e) { console.error(e); UIManager.toast("Profile load error"); }
            },

            saveProfile: async (name, color) => {
                const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'users', State.currentUser.uid, 'profile', 'settings');
                await setDoc(ref, { displayName: name, preferredColor: color });
                await API.loadProfile();
            },

            presence: {
                start: () => {
                    const hb = () => {
                        if(!State.currentUser?.profile) return;
                        const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'online_users', State.currentUser.uid);
                        setDoc(ref, { displayName: State.currentUser.profile.displayName, lastSeen: Date.now() }, { merge: true });
                    };
                    hb(); setInterval(hb, 30000);

                    const onlineRef = collection(State.db, 'artifacts', CONSTANTS.APP_ID, 'online_users');
                    State.subs.online = onSnapshot(onlineRef, (snap) => {
                        UIManager.renderOnlineList(snap);
                    });
                },
                setStatus: (status) => {
                    if(!State.currentUser) return;
                    const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'online_users', State.currentUser.uid);
                    setDoc(ref, { status: status }, { merge: true });
                },
                listenInvites: () => {
                    const q = query(collection(State.db, 'artifacts', CONSTANTS.APP_ID, 'invites'), where("toUid", "==", State.currentUser.uid));
                    State.subs.invites = onSnapshot(q, (snap) => {
                        snap.docChanges().forEach(change => {
                            if(change.type === "added" && (Date.now() - change.doc.data().timestamp < 300000)) {
                                UIManager.showInvite(change.doc.data(), change.doc.id);
                            }
                        });
                    });
                }
            },

            lobby: {
                create: async (name, energy, color) => {
                    const coll = collection(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games');
                    // Purge old
                    const q = query(coll, where("players", "array-contains", { userId: State.currentUser.uid })); // Simplified purge query
                    // (Actual purge logic simplified for brevity, keeping robust create logic)
                    
                    const gameData = {
                        lobbyName: name,
                        status: 'waitingForOpponent',
                        createdAt: Date.now(),
                        maxEnergy: parseInt(energy),
                        energyPool: parseInt(energy),
                        pendingEnergyRefund: 0,
                        turn: 0,
                        phase: 'setup',
                        lastShotVector: null,
                        log: [`Lobby '${name}' created.`],
                        players: [{
                            userId: State.currentUser.uid,
                            displayName: State.currentUser.profile.displayName,
                            color: color,
                            nexusLocation: null,
                            nexusHP: CONSTANTS.NEXUS_HP,
                            buildings: [],
                            isReady: false
                        }]
                    };
                    const ref = await addDoc(coll, gameData);
                    API.game.listen(ref.id);
                },
                join: async (gameId) => {
                    const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', gameId);
                    const snap = await getDoc(ref);
                    if(!snap.exists()) return UIManager.toast("Game not found");
                    const data = snap.data();
                    
                    if(data.players[0].userId === State.currentUser.uid) {
                        API.game.listen(gameId); // Re-join own game
                        return;
                    }
                    
                    // Logic to pick color not taken
                    let myColor = State.currentUser.profile.preferredColor;
                    if(data.players[0].color === myColor) myColor = CONSTANTS.COLORS.find(c => c !== myColor) || 'Blue';

                    const p2 = {
                        userId: State.currentUser.uid,
                        displayName: State.currentUser.profile.displayName,
                        color: myColor,
                        nexusHP: CONSTANTS.NEXUS_HP,
                        buildings: [],
                        isReady: false,
                        nexusLocation: null
                    };
                    
                    await updateDoc(ref, { 
                        players: [data.players[0], p2], 
                        status: 'waitingForHostStart',
                        log: [...data.log, `${p2.displayName} joined.`]
                    });
                    API.game.listen(gameId);
                },
                leave: async () => {
                    if(!State.gameId) return;
                    const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId);
                    
                    if(State.game.players.length <= 1) {
                        await deleteDoc(ref);
                    } else {
                        // Remove self
                        const remaining = State.game.players.filter(p => p.userId !== State.currentUser.uid);
                        await updateDoc(ref, { players: remaining, status: 'waitingForOpponent' });
                    }
                    API.game.stopListening();
                    UIManager.show('lobbyList');
                }
            },

            game: {
                listen: (id) => {
                    if(State.subs.game) State.subs.game();
                    State.gameId = id;
                    DOM.gameId.textContent = id;
                    
                    State.subs.game = onSnapshot(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', id), (snap) => {
                        // 1. Handle Lobby Deletion (Host left or Game deleted)
                        if(!snap.exists()) { 
                            API.game.stopListening(); 
                            UIManager.showModal("Lobby Closed", false); 
                            UIManager.show('lobbyList'); // Ensure we go back to list
                            return; 
                        }
                        
                        const newData = snap.data();

                        // --- KICK DETECTION & HANDLING ---
                        // Check if we are still in the players list
                        const amIStillInGame = newData.players.some(p => p.userId === State.currentUser.uid);
                        
                        // If the document exists, but we aren't in it, we were kicked.
                        if (!amIStillInGame) {
                            API.game.stopListening(); // Clean up local listeners/presence
                            UIManager.toast("You have been kicked by the host.");
                            UIManager.show('lobbyList'); // Send back to menu
                            return; // Stop processing this update
                        }
                        // ----------------------------------

                        // === NEW ANIMATION TRIGGER ===
                        if (newData.lastLaserPath && newData.lastAttackId && 
                        (newData.lastAttackId !== State.game?.lastAttackId)) {
                            
                            const pathArray = JSON.parse(newData.lastLaserPath);
                            const shooterIndex = (newData.turn + 1) % 2;
                            // Safe check in case a player left mid-shot calculation (rare edge case)
                            const shooterColor = newData.players[shooterIndex] ? newData.players[shooterIndex].color : 'Red';

                            UIManager.animateLaser(pathArray, shooterColor);
                        }
                        // =============================

                        State.game = newData;
                        State.playerIndex = State.game.players.findIndex(p => p.userId === State.currentUser.uid);
                        
                        if(State.game.status === 'inProgress' || State.game.status === 'gameOver') {
                            UIManager.show('game');
                            UIManager.renderGame();
                        } else {
                            UIManager.show('waitingRoom');
                            UIManager.renderWaitingRoom();
                        }
                    });
                },
                stopListening: () => {
                    if(State.subs.game) State.subs.game();
                    State.gameId = null;
                    State.game = null;
                    API.presence.setStatus('Available');
                },
                
                // --- Actions ---
                toggleReady: async () => {
                    const newP = [...State.game.players];
                    newP[State.playerIndex].isReady = !newP[State.playerIndex].isReady;
                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), { players: newP });
                },
                startGame: async () => {
                    // 1. Deep Reset of Players (keep ID/Name/Color/Ready, wipe board data)
                    const resetPlayers = State.game.players.map(p => ({
                        userId: p.userId,
                        displayName: p.displayName,
                        color: p.color,
                        isReady: p.isReady, // Keep ready state or reset? usually keep until game actually inits
                        nexusLocation: null,
                        nexusStartLoc: null,
                        nexusHP: CONSTANTS.NEXUS_HP,
                        buildings: []
                    }));

                    // 2. Push Full Reset Update
                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        status: 'inProgress', 
                        phase: 'setup', 
                        turn: 0, 
                        energyPool: State.game.maxEnergy,
                        pendingEnergyRefund: 0,
                        lastShotVector: null,
                        lastLaserPath: null,
                        lastAttackId: null,
                        turnBudget: 0,
                        players: resetPlayers,
                        log: [`Game Started! State Reset.`]
                    });
                },
                placeNexus: async (loc) => {
                    const newP = JSON.parse(JSON.stringify(State.game.players));
                    newP[State.playerIndex].nexusLocation = loc;
                    newP[State.playerIndex].nexusStartLoc = loc;
                    
                    let updates = { players: newP, log: [...State.game.log, "Nexus Placed."] };
                    
                    // Check if both ready
                    const p1 = newP[0], p2 = newP[1];
                    if(p1.nexusLocation && (newP.length === 1 || p2?.nexusLocation)) {
                        updates.phase = 'buyMove';
                        const newEnergyPool = State.game.maxEnergy;
                        updates.energyPool = newEnergyPool;
                        // Player 0 (turn 0) has 0 pylons. Budget = min(0 + 1, energyPool)
                        updates.turnBudget = Math.min(1, newEnergyPool);
                        updates.log.push("All Nexus placed. Phase: Buy/Move");
                    }
                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), updates);
                },
                placeBuilding: async (type, loc, orientation) => {
                    const cost = (type === 'pylon' || type === 'mirror') ? 1 : 0;
                    const newP = JSON.parse(JSON.stringify(State.game.players));

                    const newBuilding = { type, location: loc, hp: CONSTANTS.BUILDING_HP };
                    if (type === 'mirror') {
                        newBuilding.orientation = orientation || 'N'; // Add orientation, default to 'N'
                    }
                    newP[State.playerIndex].buildings.push(newBuilding);

                    const logMsg = (type === 'mirror') ? `Placed ${orientation} Mirror.` : `Placed ${type}.`;

                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        players: newP,
                        energyPool: State.game.energyPool - cost,
                        turnBudget: State.game.turnBudget - cost,
                        log: [...State.game.log, logMsg]
                    });
                },
                moveNexus: async (to) => {
                    const newP = JSON.parse(JSON.stringify(State.game.players));
                    newP[State.playerIndex].nexusLocation = to;
                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        players: newP,
                        log: [...State.game.log, "Nexus Moved."]
                    });
                },
                endPhase: async () => {
                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        phase: 'attack',
                        log: [...State.game.log, "Attack Phase."]
                    });
                },
                attack: async (dx, dy) => {
                    try {
                        const startLoc = State.game.players[State.playerIndex].nexusLocation;
                        const { path, hits, log } = GameLogic.traceLaser(startLoc, [dx, dy], State.game);
                        
                        // Apply Damage
                        const newP = JSON.parse(JSON.stringify(State.game.players));
                        let destroyedCount = 0;
                        let gameOver = false;
                        let winner = -1;

                        hits.forEach(h => {
                            if (h.type === 'nexus') {
                                newP[h.ownerIdx].nexusHP--;
                                if(newP[h.ownerIdx].nexusHP <= 0) { gameOver = true; winner = State.playerIndex; }
                            } else {
                                newP[h.ownerIdx].buildings = newP[h.ownerIdx].buildings.filter(b => 
                                    !(b.location[0] === h.location[0] && b.location[1] === h.location[1])
                                );
                                destroyedCount++;
                            }
                        });

                        const nextTurn = (State.game.turn + 1) % 2;
                        // Apply refunds
                        const nextPool = State.game.energyPool + State.game.pendingEnergyRefund;

                        // Calculate next player's budget
                        const nextPlayer = newP[nextTurn];
                        const nextPlayerPylons = nextPlayer.buildings ? nextPlayer.buildings.filter(b => b.type === 'pylon').length : 0;
                        const newTurnBudget = Math.min(nextPlayerPylons + 1, nextPool);
                        
                        if(newP[nextTurn].nexusLocation) newP[nextTurn].nexusStartLoc = newP[nextTurn].nexusLocation;

                        let updates = {
                            players: newP,
                            log: [...State.game.log, ...log],
                            lastShotVector: [dx, dy],
                            lastLaserPath: JSON.stringify(path),
                            lastAttackId: Date.now(),
                            turn: nextTurn,
                            phase: 'buyMove',
                            energyPool: nextPool,
                            turnBudget: newTurnBudget,
                            pendingEnergyRefund: destroyedCount
                        };
                        
                        if(gameOver) {
                            updates.status = 'gameOver';
                            updates.winner = winner;
                            updates.log.push("GAME OVER!");
                        }

                        await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), updates);
                        
                        // Removed local animation call here, handled by listener now
                    } catch (err) {
                        console.error("Attack Error:", err);
                        UIManager.toast("Error attacking: " + err.message);
                    }
                },
                skipAttack: async () => {
                    const nextTurn = (State.game.turn + 1) % 2;
                    const newP = JSON.parse(JSON.stringify(State.game.players));
                    if(newP[nextTurn].nexusLocation) newP[nextTurn].nexusStartLoc = newP[nextTurn].nexusLocation;

                    const newEnergyPool = State.game.energyPool + State.game.pendingEnergyRefund;
                    const nextPlayer = newP[nextTurn];
                    const nextPlayerPylons = nextPlayer.buildings ? nextPlayer.buildings.filter(b => b.type === 'pylon').length : 0;
                    const newTurnBudget = Math.min(nextPlayerPylons + 1, newEnergyPool);

                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        turn: nextTurn,
                        phase: 'buyMove',
                        energyPool: newEnergyPool,
                        turnBudget: newTurnBudget,
                        pendingEnergyRefund: 0,
                        lastShotVector: null,
                        lastLaserPath: null,
                        lastAttackId: null,
                        players: newP,
                        log: [...State.game.log, "Attack Skipped."]
                    });
                },

                updateSettings: async (newName, newEnergy) => {
                    if (State.playerIndex !== 0) return; // Host only

                    const newP = JSON.parse(JSON.stringify(State.game.players));
                    let newLogs = [...State.game.log];

                    if (newP[1]) {
                        newP[1].isReady = false; // Un-ready the guest
                        newLogs.push("Host changed settings. Guest un-readied.");
                    } else {
                        newLogs.push("Host changed settings.");
                    }

                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        lobbyName: newName,
                        maxEnergy: parseInt(newEnergy),
                        energyPool: parseInt(newEnergy), // Also update the pool to match
                        players: newP,
                        log: newLogs
                    });
                },

                kickGuest: async () => {
                    if (State.playerIndex !== 0 || State.game.players.length < 2) return; // Host only

                    const hostPlayer = State.game.players[0];
                    hostPlayer.isReady = false; // Reset host ready state

                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        players: [hostPlayer], // Set players array to only host
                        status: 'waitingForOpponent',
                        log: [...State.game.log, `${State.game.players[1].displayName} was kicked by the host.`]
                    });
                }
            }
        };

        // ==========================================
        // 6. UI MANAGER (Rendering)
        // ==========================================
        const UIManager = {
            show: (viewName) => {
                Object.values(DOM.views).forEach(v => v.classList.add('hidden'));
                if(DOM.views[viewName]) DOM.views[viewName].classList.remove('hidden');
                if(viewName === 'lobbyList') API.presence.setStatus('Available');
                else if (viewName === 'game' || viewName === 'waitingRoom') API.presence.setStatus('Busy');
            },
            toast: (msg) => {
                const el = document.createElement('div');
                el.className = 'absolute top-5 right-5 bg-red-600 text-white p-3 rounded shadow-lg z-50';
                el.textContent = msg;
                document.body.appendChild(el);
                setTimeout(() => el.remove(), 3000);
            },
            showModal: (msg, isEndGame) => {
                DOM.modalMsg.innerHTML = `<p>${msg}</p>`;
                DOM.$('#new-game-btn').classList.toggle('hidden', !isEndGame);
                DOM.views.modal.classList.remove('hidden');
            },
            populateColors: (select) => {
                select.innerHTML = '';
                CONSTANTS.COLORS.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c; opt.textContent = c;
                    select.appendChild(opt);
                });
            },
            renderOnlineList: (snap) => {
                DOM.onlineList.innerHTML = '';
                snap.forEach(doc => {
                    const d = doc.data();
                    if (Date.now() - d.lastSeen > 120000 || doc.id === State.currentUser.uid) return;
                    const el = document.createElement('div');
                    el.className = 'flex justify-between p-2 bg-gray-800 rounded mb-1';
                    el.innerHTML = `<span>${d.displayName}</span><span class="text-xs text-gray-400">${d.status || 'Online'}</span>`;
                    // Add invite button if available logic here...
                    DOM.onlineList.appendChild(el);
                });
            },
            showInvite: (data, id) => {
                DOM.modalMsg.innerHTML = `Invite from ${data.fromName}!`;
                // Add Accept/Decline buttons dynamically via DOM for security/simplicity
                const btn = document.createElement('button');
                btn.className = "bg-green-500 text-white p-2 rounded mt-2";
                btn.textContent = "Accept";
                btn.onclick = () => { 
                    deleteDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'invites', id));
                    API.lobby.join(data.gameId);
                    DOM.views.modal.classList.add('hidden');
                };
                DOM.modalMsg.appendChild(btn);
                DOM.views.modal.classList.remove('hidden');
            },
            
            renderWaitingRoom: () => {
                const g = State.game;
                const p1 = g.players[0];
                const p2 = g.players[1];
                const isHost = State.playerIndex === 0;

                // === Host Settings Panel ===
                const hostPanel = DOM.$('#host-settings-panel');
                const lobbyNameInput = DOM.$('#waiting-lobby-name-input');
                const energySelect = DOM.$('#waiting-energy-pool-select');

                if (isHost) {
                    hostPanel.classList.remove('hidden');
                    lobbyNameInput.disabled = false;
                    energySelect.disabled = false;
                    
                    lobbyNameInput.value = g.lobbyName;
                    energySelect.value = g.maxEnergy;

                    // Add event listeners that update settings and un-ready P2
                    lobbyNameInput.onchange = (e) => {
                        API.game.updateSettings(e.target.value, energySelect.value);
                    };
                    energySelect.onchange = (e) => {
                        API.game.updateSettings(lobbyNameInput.value, e.target.value);
                    };

                } else {
                    // Guest just sees the panel, but disabled
                    hostPanel.classList.remove('hidden');
                    lobbyNameInput.value = g.lobbyName;
                    energySelect.value = g.maxEnergy;
                    lobbyNameInput.disabled = true;
                    energySelect.disabled = true;
                }

                // This text display is now redundant, but we'll update it anyway
                DOM.$('#waiting-lobby-name').textContent = g.lobbyName;

                // Helper to render player box
                const renderBox = (p, prefix, isMe) => {
                    const nameEl = DOM.$(`#${prefix}-name`);
                    const rInd = DOM.$(`#${prefix}-ready-indicator`);
                    const sel = DOM.$(`#${prefix}-color-select`);
                    
                    // Find kick button (only used for p2)
                    const kickBtn = DOM.$('#kick-p2-btn');
                    
                    // Hiding the old small buttons, we use the big main button now
                    DOM.$(`#${prefix}-ready-btn`).classList.add('hidden');

                    if(!p) {
                        nameEl.textContent = "Empty"; 
                        nameEl.classList.add('text-gray-500');
                        rInd.classList.add('hidden'); 
                        sel.classList.add('hidden');
                        if (prefix === 'p2') kickBtn.classList.add('hidden'); // Hide kick button if no P2
                        return;
                    }

                    nameEl.textContent = p.displayName + (isMe ? " (You)" : "");
                    nameEl.classList.remove('text-gray-500');
                    
                    // Host is always "Ready" implicitly, so we only care about Guest readiness visually
                    if (prefix === 'p1') {
                        rInd.textContent = "HOST";
                        rInd.className = "mt-2 text-xs font-bold text-cyan-500 uppercase tracking-widest";
                    } else {
                        rInd.classList.remove('hidden');
                        rInd.textContent = p.isReady ? "READY" : "NOT READY";
                        rInd.className = p.isReady ? "mt-2 text-xs font-bold text-green-500 uppercase tracking-widest" : "mt-2 text-xs font-bold text-red-500 uppercase tracking-widest";

                        // Show/bind kick button
                        if (isHost) {
                            kickBtn.classList.remove('hidden');
                            kickBtn.onclick = API.game.kickGuest;
                        } else {
                            kickBtn.classList.add('hidden');
                        }
                    }
                    
                    sel.classList.remove('hidden');
                    if (sel.options.length === 0) UIManager.populateColors(sel);
                    sel.value = p.color;
                    sel.disabled = !isMe;
                    if(isMe) {
                        sel.onchange = async (e) => {
                            const newP = [...State.game.players];
                            newP[State.playerIndex].color = e.target.value;
                            // Changing color shouldn't un-ready anyone, so just update players
                            await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), { players: newP });
                        };
                    }
                };
                
                renderBox(p1, 'p1', State.playerIndex === 0);
                renderBox(p2, 'p2', State.playerIndex === 1);
                
                // Main Button Logic
                const mainBtn = DOM.$('#start-game-btn');
                
                if(isHost) {
                    // Host Logic: Start Game
                    const p2Ready = p2 && p2.isReady;
                    mainBtn.textContent = p2Ready ? "Start Game" : (p2 ? "Waiting for Guest..." : "Waiting for Player...");
                    mainBtn.disabled = !p2Ready;
                    mainBtn.onclick = API.game.startGame;
                    
                    // Styling: Green if ready, Gray if not
                    mainBtn.className = `w-full font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg mb-3 ${p2Ready ? 'bg-green-600 hover:bg-green-500 text-white cursor-pointer' : 'bg-gray-700 text-gray-400 cursor-not-allowed opacity-75'}`;
                } else if (State.playerIndex === 1) { // Check if guest
                    // Guest Logic: Toggle Ready
                    const amIReady = g.players[State.playerIndex].isReady;
                    mainBtn.textContent = amIReady ? "Cancel Ready" : "Ready Up";
                    mainBtn.disabled = false;
                    mainBtn.onclick = API.game.toggleReady;

                    // Styling: Yellow if ready (to cancel), Green if not ready
                    mainBtn.className = `w-full font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg mb-3 cursor-pointer ${amIReady ? 'bg-yellow-600 hover:bg-yellow-500 text-white' : 'bg-green-600 hover:bg-green-500 text-white'}`;
                } else {
                    // Spectator/Error state?
                    mainBtn.classList.add('hidden');
                }
            },
            
            renderGame: () => {
                const g = State.game;
                const myP = g.players[State.playerIndex];
                if(!myP) return; 
                
                const turnP = g.players[g.turn];
                
                // SAFE COLOR LOOKUP: Defaults to 'text-white' if color map fails
                const getTextColor = (colorName) => {
                    const c = CONSTANTS.COLOR_MAP[colorName];
                    return (c && c.text) ? c.text : 'text-white';
                };

                const myColorClass = getTextColor(myP.color);
                const turnColorClass = getTextColor(turnP.color);

                // Update HUD
                DOM.playerNum.innerHTML = `<span class="${myColorClass}">${myP.displayName}</span>`;
                DOM.turn.innerHTML = `<span class="${turnColorClass}">${turnP.displayName}</span>`;
                
                DOM.phase.textContent = g.phase;
                DOM.energy.textContent = g.energyPool;
                
                // Calc Budget
                const budget = (g.turn === State.playerIndex && g.phase === 'buyMove') ? (g.turnBudget || 0) : 0;
                DOM.budget.textContent = budget;
                
                // Render sub-components
                UIManager.renderBoard();
                UIManager.renderControls(budget);
                
                // Render Log
                if(DOM.gameLog && g.log) {
                    DOM.gameLog.innerHTML = g.log.map(l => `<div class="border-b border-gray-700 py-1">${l}</div>`).join('');
                    DOM.gameLog.scrollTop = DOM.gameLog.scrollHeight;
                }

                if(g.status === 'gameOver') UIManager.showModal(`Game Over! Winner: ${g.players[g.winner].displayName}`, true);
            },
            
            renderBoard: () => {
                const g = State.game;
                DOM.gameBoard.innerHTML = '';
                const myZoneStart = State.playerIndex === 0 ? 0 : 5;
                const myZoneEnd = State.playerIndex === 0 ? 5 : 10;

                for(let r=0; r<CONSTANTS.BOARD_ROWS; r++){
                    for(let c=0; c<CONSTANTS.BOARD_COLS; c++){
                        const cell = document.createElement('div');
                        cell.className = 'relative aspect-square border border-indigo-500/30 transition-all duration-150';
                        cell.dataset.r = r; cell.dataset.c = c;

                        const isMyZone = c >= myZoneStart && c < myZoneEnd;
                        if(isMyZone) cell.classList.add(CONSTANTS.COLOR_MAP[g.players[State.playerIndex].color].bg);
                        else cell.classList.add('bg-gray-800/50'); // Shroud style

                        const unit = GameLogic.getUnitAt(r, c, g);
                        if(unit) {
                            if(isMyZone || unit.ownerIdx === State.playerIndex) { // Simple FOW: Only see own side or own units
                                const color = CONSTANTS.COLOR_MAP[g.players[unit.ownerIdx].color];

                                let svg;
                                if (unit.type === 'nexus') {
                                    svg = CONSTANTS.SVGS.NEXUS;
                                } else if (unit.type === 'pylon') {
                                    svg = CONSTANTS.SVGS.PYLON; // This was broken in your code
                                } else if (unit.type === 'mirror') {
                                    const orientation = unit.orientation || 'N';
                                    const shape = CONSTANTS.SVGS.MIRROR_SHAPES[orientation];
                                    svg = `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${shape}</svg>`;
                                }

                                const maxHp = unit.type === 'nexus' ? CONSTANTS.NEXUS_HP : CONSTANTS.BUILDING_HP;
                                cell.innerHTML = `<div class="absolute inset-0 p-1 ${color.stroke} ${color.bg}">${svg}</div><div class="absolute bottom-0 right-0 text-[10px] bg-black/80 px-1 text-white">${unit.hp}/${maxHp}</div>`;
                            }
                        }

                        // Interaction Highlights
                        if(State.currentAction === 'setup' && isMyZone && !unit) cell.classList.add('cursor-pointer', 'hover:bg-white/20');
                        if(State.currentAction === 'place-pylon' && isMyZone && !unit) cell.classList.add('cursor-pointer', 'hover:bg-cyan-500/50');
                        if(State.currentAction === 'place-mirror' && isMyZone && !unit) cell.classList.add('cursor-pointer', 'hover:bg-purple-500/50');
                        if(State.currentAction === 'move-nexus-target' && !unit) {
                            if(GameLogic.isValidNexusMove(State.selectedLocation, [r,c], State.playerIndex, g)) {
                                cell.classList.add('cursor-pointer', 'bg-yellow-500/30', 'animate-pulse');
                            }
                        }

                        cell.onclick = () => Handlers.boardClick(r, c);
                        DOM.gameBoard.appendChild(cell);
                    }
                }
            },

            renderControls: (budget) => {
                const g = State.game;
                const isMyTurn = g.turn === State.playerIndex;
                const controls = { 
                    setup: DOM.$('#setup-controls'), 
                    buy: DOM.$('#buy-move-controls'), 
                    attack: DOM.$('#attack-controls'), 
                    waiting: DOM.$('#waiting-controls') 
                };
                
                // 1. Reset: Hide all control panels
                Object.values(controls).forEach(el => {
                    if(el) el.classList.add('hidden');
                });

                // 2. Safely hide the old waiting message if it still exists in DOM
                const oldMsg = DOM.$('#setup-waiting-msg');
                if (oldMsg) oldMsg.classList.add('hidden');

                // 3. Show relevant controls
                if(g.phase === 'setup') {
                    if(!g.players[State.playerIndex].nexusLocation) {
                        if(controls.setup) controls.setup.classList.remove('hidden');
                        State.currentAction = 'setup';
                        
                        const btn = DOM.$('#confirm-nexus-btn');
                        if(btn) {
                            btn.disabled = !State.selectedLocation;
                            btn.textContent = State.selectedLocation ? "Confirm Location" : "Select Cell";
                            btn.onclick = () => API.game.placeNexus(State.selectedLocation);
                        }
                    } else {
                        if(controls.waiting) controls.waiting.classList.remove('hidden');
                    }
                }
                else if (!isMyTurn) { 
                    if(controls.waiting) controls.waiting.classList.remove('hidden'); 
                }
                else if (g.phase === 'buyMove') {
                    if(controls.buy) controls.buy.classList.remove('hidden');
                    const btnPylon = DOM.$('#place-pylon-btn');
                    const btnMirror = DOM.$('#place-mirror-btn');
                    if(btnPylon) btnPylon.disabled = (budget < 1 || g.energyPool < 1);
                    if(btnMirror) btnMirror.disabled = (budget < 1 || g.energyPool < 1);
                }
                else if (g.phase === 'attack') {
                    if(controls.attack) controls.attack.classList.remove('hidden');
                }
            },
            
            animateLaser: (path, colorName) => {
                // Get Hex from constants, default to Red
                const hex = CONSTANTS.LASER_COLORS[colorName] || '#ff0000';

                // Clean up any old laser beams immediately before starting a new one
                DOM.$$('.laser-beam-svg').forEach(el => el.remove());
                DOM.$$('.laser-active').forEach(el => el.classList.remove('laser-active'));

                let i = 1;
                const interval = setInterval(() => {
                    if(i + 1 >= path.length) { 
                        clearInterval(interval); 
                        // Optional: Auto-remove beams after a delay, or let CSS fade handle it
                        setTimeout(() => {
                             DOM.$$('.laser-beam-svg').forEach(el => el.remove());
                             DOM.$$('.laser-active').forEach(el => el.classList.remove('laser-active'));
                        }, 2000);
                        return; 
                    }

                    const [r, c] = path[i];
                    const cell = DOM.$(`[data-r="${r}"][data-c="${c}"]`);

                    if(cell) { 
                        // 1. Calculate Direction (Delta)
                        let dr = 0, dc = 0;
                        const next = path[i+1];
                        const prev = path[i-1];

                        if (prev) {
                            // --- Calculate INCOMING vector ---
                            const dr_in = r - prev[0];
                            const dc_in = c - prev[1];

                            // --- Set default vector (use incoming) ---
                            dr = dr_in;
                            dc = dc_in;

                            if (next) {
                                // --- Calculate OUTGOING vector ---
                                const dr_out = next[0] - r;
                                const dc_out = next[1] - c;

                                // --- CORNER LOGIC ---
                                // Check if incoming was Straight (H or V)
                                const isIncomingStraight = (dr_in === 0 || dc_in === 0);
                                // Check if outgoing is Diagonal
                                const isOutgoingDiagonal = (dr_out !== 0 && dc_out !== 0);

                                if (isIncomingStraight && isOutgoingDiagonal) {
                                    // This is the "skid" cell turning into a diagonal.
                                    // Override the vector to use the OUTGOING one.
                                    dr = dr_out;
                                    dc = dc_out;
                                }
                            }
                            // (else, it's the end of the line, default (dr_in, dc_in) is correct)
                        } else if (next) { 
                            // Start of line: Calculate based on where we are going
                            dr = next[0] - r;
                            dc = next[1] - c;
                        }

                        // 2. Determine Line Coordinates based on Delta
                        // Default to Center-Center (dot) if no movement
                        let x1 = "50%", y1 = "50%", x2 = "50%", y2 = "50%";

                        if (dr === 0 && dc !== 0) { 
                            // Horizontal (-)
                            x1 = "0%"; y1 = "50%"; x2 = "100%"; y2 = "50%";
                        } else if (dr !== 0 && dc === 0) { 
                            // Vertical (|)
                            x1 = "50%"; y1 = "0%"; x2 = "50%"; y2 = "100%";
                        } else if ((dr === 1 && dc === 1) || (dr === -1 && dc === -1)) { 
                            // Diagonal Main (\) (NW to SE or SE to NW)
                            x1 = "0%"; y1 = "0%"; x2 = "100%"; y2 = "100%";
                        } else if ((dr === 1 && dc === -1) || (dr === -1 && dc === 1)) { 
                            // Diagonal Anti (/) (NE to SW or SW to NE)
                            x1 = "100%"; y1 = "0%"; x2 = "0%"; y2 = "100%";
                        }

                        // 3. Set CSS Var for color (used by CSS animations)
                        cell.style.setProperty('--laser-color', hex);

                        // 4. Inject SVG Line
                        const svg = document.createElement('div');
                        svg.className = 'laser-beam-svg';
                        svg.innerHTML = `<svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none">
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${hex}" stroke-width="15" stroke-linecap="round" />
                        </svg>`;
                        cell.appendChild(svg);

                        // 5. Trigger Background Pulse
                        cell.classList.remove('laser-active'); // reset if needed
                        void cell.offsetWidth; // force reflow
                        cell.classList.add('laser-active'); 
                    }
                    i++;
                }, 30); // Slightly faster speed (30ms) for a snappier beam
            }
        };

        // ==========================================
        // 7. EVENT HANDLERS
        // ==========================================
        const Handlers = {
            init: () => {
                DOM.$('#save-profile-btn').onclick = () => API.saveProfile(DOM.$('#profile-display-name').value, DOM.$('#profile-color-select').value);
                DOM.$('#multi-player-btn').onclick = () => {
                    UIManager.show('lobbyList');
                    API.presence.start();
                    // Instead of creating a test lobby, we now just refresh the list
                    DOM.$('#refresh-lobbies-btn').click();
                };
                DOM.$('#refresh-lobbies-btn').onclick = async () => {
                    DOM.lobbyListContainer.innerHTML = "Cleaning & Loading...";
                    
                    // 1. Get all waiting games
                    const q = query(collection(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games'), where("status", "==", "waitingForOpponent"));
                    const snap = await getDocs(q);
                    
                    DOM.lobbyListContainer.innerHTML = "";
                    
                    // 2. Iterate through them
                    snap.forEach(async (docSnapshot) => { // renamed to docSnapshot to avoid confusion
                        const d = docSnapshot.data();
                        
                        // 3. Check Age (5 minutes = 300,000 ms)
                        // If createdAt is missing (old games), default to 0 so they get cleaned up, or Date.now() to keep them.
                        const createdAt = d.createdAt || 0; 
                        const age = Date.now() - createdAt;

                        if (age > 300000) {
                            // If older than 5 mins, DELETE IT and do not render
                            console.log(`Cleaning up ghost lobby: ${d.lobbyName}`);
                            await deleteDoc(docSnapshot.ref);
                            return; 
                        }

                        // 4. If valid, Render it (Existing logic)
                        const btn = document.createElement('div');
                        btn.className = "bg-gray-800 p-4 rounded flex justify-between items-center cursor-pointer hover:bg-gray-700 border border-indigo-500/30";
                        btn.innerHTML = `<div><div class="font-bold text-cyan-400">${d.lobbyName}</div><div class="text-xs text-gray-400">Host: ${d.players[0].displayName}</div></div><button class="bg-green-600 px-3 py-1 rounded text-white">Join</button>`;
                        btn.onclick = () => API.lobby.join(docSnapshot.id);
                        DOM.lobbyListContainer.appendChild(btn);
                    });

                    if (DOM.lobbyListContainer.innerHTML === "") {
                        DOM.lobbyListContainer.innerHTML = "<div class='text-gray-500 text-center mt-4'>No active lobbies found.</div>";
                    }
                };
                DOM.$('#show-create-lobby-btn').onclick = () => {
                    const defaultName = `${State.currentUser.profile.displayName}'s Game`;
                    const defaultEnergy = 10;
                    const defaultColor = State.currentUser.profile.preferredColor;
                    
                    API.lobby.create(defaultName, defaultEnergy, defaultColor);
                };
                DOM.$('#create-lobby-btn').onclick = () => API.lobby.create(DOM.$('#lobby-name-input').value, DOM.$('#energy-pool-select').value, DOM.$('#host-color-select').value);
                DOM.$('#cancel-create-lobby-btn').onclick = () => UIManager.show('lobbyList');
                DOM.$('#leave-lobby-btn').onclick = API.lobby.leave;
                DOM.$('#back-to-main-menu-btn').onclick = () => UIManager.show('lobby');
                DOM.$('#p1-ready-btn').onclick = API.game.toggleReady;
                DOM.$('#p2-ready-btn').onclick = API.game.toggleReady;
                DOM.$('#new-game-btn').onclick = () => { DOM.views.modal.classList.add('hidden'); API.lobby.leave(); };

                // Game Actions
                DOM.$('#place-pylon-btn').onclick = () => { State.currentAction = 'place-pylon'; UIManager.renderBoard(); };
                DOM.$('#place-mirror-btn').onclick = () => { State.currentAction = 'place-mirror'; UIManager.renderBoard(); };
                DOM.$('#move-nexus-btn').onclick = () => { 
                    State.currentAction = 'move-nexus-target'; 
                    State.selectedLocation = State.game.players[State.playerIndex].nexusLocation;
                    UIManager.renderBoard(); 
                };
                DOM.$('#cancel-action-btn').onclick = () => { State.currentAction = null; State.selectedLocation = null; UIManager.renderBoard(); };
                DOM.$('#end-phase-btn').onclick = API.game.endPhase;

                DOM.$$('.mirror-rotate-btn').forEach(btn => {
                    btn.onclick = () => {
                        const orientation = btn.dataset.orientation;
                        State.currentMirrorOrientation = orientation;
                        DOM.$('#mirror-orientation-display').textContent = orientation;
                    };
                });
                
                DOM.$$('button[data-dir]').forEach(btn => {
                    btn.onclick = () => {
                        const dir = CONSTANTS.DIRECTIONS[btn.dataset.dir];
                        API.game.attack(dir[0], dir[1]);
                    };
                });
                DOM.$('#skip-attack-btn').onclick = API.game.skipAttack;
            },
            
            boardClick: (r, c) => {
                const act = State.currentAction;
                const isMine = (c >= (State.playerIndex === 0 ? 0 : 5) && c < (State.playerIndex === 0 ? 5 : 10));
                
                if(act === 'setup' && isMine && !GameLogic.getUnitAt(r,c, State.game)) {
                    State.selectedLocation = [r,c];
                    UIManager.renderBoard();
                    UIManager.renderControls(); // Enable button
                }
                if((act === 'place-pylon' || act === 'place-mirror') && isMine && !GameLogic.getUnitAt(r,c, State.game)) {
                    const type = act.split('-')[1];
                    const orientation = (type === 'mirror') ? State.currentMirrorOrientation : null;
                    API.game.placeBuilding(type, [r,c], orientation);
                    State.currentAction = null;
                }
                if(act === 'move-nexus-target') {
                    if(GameLogic.isValidNexusMove(State.selectedLocation, [r,c], State.playerIndex, State.game)) {
                        API.game.moveNexus([r,c]);
                        State.currentAction = null;
                    }
                }
            }
        };

        // ==========================================
        // 8. INIT
        // ==========================================
        window.addEventListener('load', () => {
            API.init();
            Handlers.init();
        });
    </script>

    <!-- Custom Styles -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Use a more sci-fi mono font for headers */
        .font-sci-mono {
            font-family: 'Orbitron', 'Courier New', monospace; /* Fallback to monospace */
        }
        
        /* Link a sci-fi font (optional, but nice) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Orbitron:wght@400;700&display=swap');

        /* Board cell styling */
        .cell {
            box-shadow: inset 0 0 2px rgba(167, 139, 250, 0.2);
        }
        .shroud-wall {
            background-image: repeating-linear-gradient(
                45deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 10px
            );
        }
        
        /* Unit styling */
        .unit {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0.9;
            filter: drop-shadow(0 0 8px currentColor);
        }
        .hp {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.7rem;
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 0 3px;
            border-radius: 2px;
        }

        /* Laser animation */
        /* The background pulse for the cell */
        @keyframes laser-pulse {
            0% { background-color: var(--laser-color); box-shadow: inset 0 0 20px var(--laser-color); }
            100% { background-color: transparent; box-shadow: none; }
        }

        /* The SVG Line itself fading out */
        @keyframes beam-fade {
            0% { opacity: 1; }
            80% { opacity: 1; } /* Stay visible for a bit */
            100% { opacity: 0; }
        }

        .laser-active {
            /* Background pulse */
            animation: laser-pulse 1s ease-out;
        }

        .laser-beam-svg {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            filter: drop-shadow(0 0 4px var(--laser-color)); /* Glow effect on the line */
            animation: beam-fade 1.5s ease-out forwards;
        }

        /* Custom scrollbar */
        #game-log::-webkit-scrollbar,
        #lobby-list-container::-webkit-scrollbar {
            width: 8px;
        }
        #game-log::-webkit-scrollbar-track,
        #lobby-list-container::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        #game-log::-webkit-scrollbar-thumb,
        #lobby-list-container::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-600 */
            border-radius: 4px;
        }
        #game-log::-webkit-scrollbar-thumb:hover,
        #lobby-list-container::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200 min-h-screen p-4 md:p-8 flex items-center justify-center">

    <div id="app" class="w-full max-w-7xl mx-auto">

        <div id="profile-view" class="hidden w-full max-w-md mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Welcome!</h1>
            <p class="text-center text-gray-300 mb-4">Please create your profile to play.</p>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Display Name</label>
                    <input id="profile-display-name" type="text" placeholder="Enter your name" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:border-indigo-500 outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Preferred Color</label>
                    <select id="profile-color-select" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:border-indigo-500 outline-none"></select>
                </div>
                <button id="save-profile-btn" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg transition-all shadow-lg">Save Profile</button>
            </div>
        </div>

        <div id="lobby-view" class="hidden w-full max-w-md mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Zero-Sum Defense</h1>
            <div class="mb-4 p-3 bg-gray-900 rounded-lg">
                <p class="text-sm text-gray-400">Welcome,</p>
                <p id="user-display-name-display" class="font-mono text-lg break-all">...</p>
                <p class="text-xs text-gray-500 mt-1">User ID: <span id="user-id-display" class="font-mono break-all">Loading...</span></p>
            </div>
            <div class="space-y-4">
                <button id="single-player-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg opacity-50 cursor-not-allowed" disabled>Singleplayer (Soon)</button>
                <button id="multi-player-btn" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg shadow-lg">Multiplayer</button>
            </div>
        </div>
        
        <div id="lobby-list-view" class="hidden w-full max-w-lg mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Open Lobbies</h1>
            <div class="flex justify-between mb-4">
                <button id="back-to-main-menu-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg">&larr; Main Menu</button>
                <button id="refresh-lobbies-btn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 px-4 rounded-lg">Refresh</button>
            </div>
            <div id="lobby-list-container" class="space-y-3 max-h-96 overflow-y-auto p-2 bg-gray-900/50 rounded-lg"></div>
            <button id="show-create-lobby-btn" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg mt-6">+ Create New Lobby</button>
        </div>

        <div id="create-lobby-view" class="hidden w-full max-w-md mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Create Lobby</h1>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Lobby Name</label>
                    <input id="lobby-name-input" type="text" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Starting Energy</label>
                    <select id="energy-pool-select" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 outline-none">
                        <option value="10">Standard (10)</option>
                        <option value="20">High (20)</option>
                        <option value="5">Low (5)</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Your Color</label>
                    <select id="host-color-select" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 outline-none"></select>
                </div>
                <div class="flex gap-4">
                    <button id="cancel-create-lobby-btn" class="w-1/2 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">Cancel</button>
                    <button id="create-lobby-btn" class="w-1/2 bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg">Create</button>
                </div>
            </div>
        </div>

        <div id="waiting-room-view" class="hidden w-full max-w-4xl mx-auto flex flex-col md:flex-row gap-4">
            <div class="flex-grow p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
                <div id="host-settings-panel" class="hidden mb-6 space-y-3 p-4 bg-gray-900/50 rounded-lg border border-indigo-500/30">
                    <h3 class="text-lg font-bold text-center font-sci-mono text-cyan-400">Host Settings</h3>
                    <div>
                        <label class="block text-sm font-medium text-gray-400 mb-1">Lobby Name</label>
                        <input id="waiting-lobby-name-input" type="text" class="w-full bg-gray-700 text-white p-2 rounded-lg border border-gray-600 outline-none disabled:opacity-50" disabled>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-400 mb-1">Starting Energy</label>
                        <select id="waiting-energy-pool-select" class="w-full bg-gray-700 text-white p-2 rounded-lg border border-gray-600 outline-none disabled:opacity-50" disabled>
                            <option value="10">Standard (10)</option>
                            <option value="20">High (20)</option>
                            <option value="5">Low (5)</option>
                        </select>
                    </div>
                </div>
                
                <h2 class="text-2xl font-bold text-center mb-2 font-sci-mono text-cyan-400">Lobby</h2>
                <h3 id="waiting-lobby-name" class="text-xl text-center text-gray-300 mb-6">...</h3>
                
                <div class="grid grid-cols-2 gap-4 text-center mb-6">
                    <div class="p-4 bg-gray-900/50 rounded-lg relative group">
                        <p class="text-xs text-gray-400 mb-1">HOST</p>
                        <p id="p1-name" class="text-lg font-bold truncate">...</p>
                        <select id="p1-color-select" class="mt-2 bg-gray-800 text-xs text-white p-1 rounded border border-gray-600 w-full disabled:opacity-50" disabled></select>
                        <div id="p1-ready-indicator" class="mt-2 text-xs font-bold text-red-500 uppercase tracking-widest">Not Ready</div>
                        <button id="p1-ready-btn" class="hidden mt-2 w-full py-1 px-2 text-xs font-bold rounded bg-gray-700 hover:bg-gray-600 transition-all">Toggle Ready</button>
                    </div>

                    <div class="p-4 bg-gray-900/50 rounded-lg relative group">
                        <p class="text-xs text-gray-400 mb-1">CHALLENGER</p>
                        <p id="p2-name" class="text-lg font-bold truncate text-gray-500">Empty</p>
                        <select id="p2-color-select" class="hidden mt-2 bg-gray-800 text-xs text-white p-1 rounded border border-gray-600 w-full"></select>
                        <div id="p2-ready-indicator" class="hidden mt-2 text-xs font-bold text-red-500 uppercase tracking-widest">Not Ready</div>
                        <button id="p2-ready-btn" class="hidden mt-2 w-full py-1 px-2 text-xs font-bold rounded bg-gray-700 hover:bg-gray-600 transition-all">Toggle Ready</button>
                        <button id="kick-p2-btn" class="hidden mt-2 w-full py-1 px-2 text-xs font-bold rounded bg-red-800 hover:bg-red-700 text-white transition-all">Kick Player</button>
                    </div>
                </div>
                
                <button id="start-game-btn" class="w-full bg-gray-600 opacity-50 cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg mb-3" disabled>Waiting...</button>
                <button id="leave-lobby-btn" class="w-full bg-red-900/80 hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg transition-all shadow-lg">Leave Lobby</button>
            </div>

            <div class="w-full md:w-64 flex-shrink-0 p-4 bg-gray-900/80 rounded-lg border border-gray-700">
                <h3 class="text-sm font-bold text-gray-400 uppercase tracking-widest mb-3 border-b border-gray-700 pb-2">Online / LFG</h3>
                <div id="online-players-list" class="space-y-2 max-h-96 overflow-y-auto text-sm">
                    <p class="text-gray-500 italic">Scanning...</p>
                </div>
            </div>
        </div>

        <div id="game-view" class="hidden w-full">
            <div class="mb-4 p-4 bg-gray-800/50 rounded-lg shadow-lg backdrop-blur-md border border-indigo-500/30 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 text-center">
                <div class="font-sci-mono"><span class="text-xs text-gray-400 block">Game ID</span><span id="game-id-display" class="text-sm break-all">...</span></div>
                <div class="font-sci-mono"><span class="text-xs text-gray-400 block">You Are</span><span id="player-number" class="text-lg font-bold">...</span></div>
                <div class="font-sci-mono"><span class="text-xs text-gray-400 block">Current Turn</span><span id="current-turn" class="text-lg font-bold">...</span></div>
                <div class="font-sci-mono"><span class="text-xs text-gray-400 block">Phase</span><span id="current-phase" class="text-lg font-bold">...</span></div>
                <div class="font-sci-mono"><span class="text-xs text-gray-400 block">Energy Pool</span><span id="energy-pool" class="text-lg font-bold text-cyan-400">10</span></div>
                <div class="font-sci-mono"><span class="text-xs text-gray-400 block">Your Budget</span><span id="player-budget" class="text-lg font-bold text-green-400">$0</span></div>
            </div>

            <div class="flex flex-col lg:flex-row gap-4">
                <div class="flex-grow">
                    <div id="game-board" class="grid grid-cols-10 gap-1 bg-gray-900/50 p-2 rounded-lg border border-indigo-500/30"></div>
                </div>

                <div class="w-full lg:w-80 xl:w-96 flex-shrink-0 flex flex-col gap-4">
                    <div id="control-panel" class="p-4 bg-gray-800/50 rounded-lg shadow-lg backdrop-blur-md border border-indigo-500/30">
                        <h3 class="text-xl font-bold mb-4 text-center font-sci-mono text-cyan-400">CONTROLS</h3>
                        
                        <div id="setup-controls" class="hidden text-center">
                            <p class="text-lg text-yellow-300 animate-pulse">Select a cell and confirm your Nexus location.</p>
                            <button id="confirm-nexus-btn" class="w-full mt-4 bg-green-600 hover:bg-green-500 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg transition-all text-lg" disabled>Confirm Placement</button>
                        </div>

                        <div id="buy-move-controls" class="hidden space-y-3">
                            <div class="grid grid-cols-2 gap-2">
                                <button id="place-pylon-btn" class="w-full bg-cyan-700 hover:bg-cyan-600 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg">Pylon (1E)</button>
                                <button id="place-mirror-btn" class="w-full bg-purple-700 hover:bg-purple-600 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg">Mirror (1E)</button>
                            </div>
                            <div id="mirror-rotation-controls" class="p-2 bg-gray-900/50 rounded-lg">
                                <p class="text-center text-xs text-gray-400 mb-2">Mirror Orientation: <span id="mirror-orientation-display" class="font-bold text-purple-300">N</span></p>
                                <div class="grid grid-cols-3 gap-1 w-32 mx-auto">
                                    <button data-orientation="NW" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">NW</button>
                                    <button data-orientation="N" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">N</button>
                                    <button data-orientation="NE" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">NE</button>
                                    <button data-orientation="W" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">W</button>
                                    <div class="aspect-square"></div>
                                    <button data-orientation="E" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">E</button>
                                    <button data-orientation="SW" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">SW</button>
                                    <button data-orientation="S" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">S</button>
                                    <button data-orientation="SE" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">SE</button>
                                </div>
                            </div>
                            <button id="move-nexus-btn" class="w-full bg-yellow-600 hover:bg-yellow-500 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg">Move Nexus</button>
                            <button id="cancel-action-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold p-2 rounded-lg text-sm">Cancel Action</button>
                            <hr class="border-gray-600 my-3">
                            <button id="end-phase-btn" class="w-full bg-green-600 hover:bg-green-500 text-white font-bold p-3 rounded-lg text-lg">Ready to Attack</button>
                        </div>

                        <div id="attack-controls" class="hidden">
                            <p class="text-center mb-3 text-lg text-red-400 animate-pulse">Select Attack Vector</p>
                            <div class="grid grid-cols-3 gap-2 w-48 mx-auto">
                                <button id="attack-nw-btn" data-dir="NW" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">NW</button>
                                <button id="attack-n-btn" data-dir="N" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">N</button>
                                <button id="attack-ne-btn" data-dir="NE" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">NE</button>
                                <button id="attack-w-btn" data-dir="W" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">W</button>
                                <div class="aspect-square flex items-center justify-center text-red-400">+</div>
                                <button id="attack-e-btn" data-dir="E" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">E</button>
                                <button id="attack-sw-btn" data-dir="SW" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">SW</button>
                                <button id="attack-s-btn" data-dir="S" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">S</button>
                                <button id="attack-se-btn" data-dir="SE" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">SE</button>
                            </div>
                            <hr class="border-gray-600 my-3">
                            <button id="skip-attack-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold p-3 rounded-lg text-lg">Skip Attack</button>
                        </div>

                        <div id="waiting-controls" class="hidden text-center">
                            <p class="text-lg text-gray-400 animate-pulse">Waiting for opponent...</p>
                        </div>
                    </div>

                    <div class="flex-grow p-4 bg-gray-800/50 rounded-lg shadow-lg backdrop-blur-md border border-indigo-500/30 min-h-[200px] lg:min-h-0">
                        <h3 class="text-xl font-bold mb-4 text-center font-sci-mono text-cyan-400">EVENT LOG</h3>
                        <div id="game-log" class="h-48 lg:h-full lg:max-h-96 overflow-y-auto space-y-2 pr-2 font-mono"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="modal-view" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
            <div class="bg-gray-800 p-8 rounded-lg shadow-xl border border-indigo-500/50 max-w-lg w-full text-center">
                <div id="modal-message" class="text-2xl mb-6">...</div>
                <button id="new-game-btn" class="hidden bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg text-lg transition-all">Back to Lobby</button>
            </div>
        </div>

    </div>
</body>
</html>