<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zero-Sum Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, addDoc, updateDoc, writeBatch, query, where, getDocs, setLogLevel, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ==========================================
        // 1. CONFIGURATION & CONSTANTS
        // ==========================================
        const CONSTANTS = {
            BOARD_ROWS: 8,
            BOARD_COLS: 10,
            NEXUS_HP: 3,
            BUILDING_HP: 1,
            COST: { PYLON: 1, MIRROR: 1 },
            NEXUS_RANGE: 3,
            COLORS: ['Red', 'Yellow', 'Blue', 'Green', 'Purple', 'Orange', 'Pink', 'Cyan'],
            COLOR_MAP: {
                'Red':    { bg: 'bg-red-900/20',    stroke: 'stroke-rose-400',    border: 'border-rose-400',    text: 'text-rose-400' },
                'Yellow': { bg: 'bg-yellow-900/20', stroke: 'stroke-yellow-400',  border: 'border-yellow-400',  text: 'text-yellow-400' },
                'Blue':   { bg: 'bg-blue-900/20',   stroke: 'stroke-blue-400',    border: 'border-blue-400',    text: 'text-blue-400' },
                'Green':  { bg: 'bg-green-900/20',  stroke: 'stroke-green-400',   border: 'border-green-400',   text: 'text-green-400' },
                'Purple': { bg: 'bg-purple-900/20', stroke: 'stroke-purple-400',  border: 'border-purple-400',  text: 'text-purple-400' },
                'Orange': { bg: 'bg-orange-900/20', stroke: 'stroke-orange-400',  border: 'border-orange-400',  text: 'text-orange-400' },
                'Pink':   { bg: 'bg-pink-900/20',   stroke: 'stroke-pink-400',    border: 'border-pink-400',    text: 'text-pink-400' },
                'Cyan':   { bg: 'bg-cyan-900/20',   stroke: 'stroke-cyan-400',    border: 'border-cyan-400',    text: 'text-cyan-400' }
            },
            VECTORS: {
                'fromN': "1,0",
                'fromNE': "1,-1",
                'fromE': "0,-1",
                'fromSE': "-1,-1",
                'fromS': "-1,0",
                'fromSW': "-1,1",
                'fromW': "0,1",
                'fromNW': "1,1",
                'toN': [-1, 0],
                'toNE': [-1,1],
                'toE': [0,1],
                'toSE': [1,1],
                'toS': [1,0],
                'toSW': [1,-1],
                'toW': [0,-1],
                'toNW': [-1,-1]
            },
            DIRECTIONS: {
                'N': [-1, 0], 'NE': [-1, 1], 'E': [0, 1], 'SE': [1, 1],
                'S': [1, 0], 'SW': [1, -1], 'W': [0, -1], 'NW': [-1, -1]
            },
            SVGS: {
                NEXUS: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path></svg>`,
                PYLON: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L7 22h10L12 2z"></path></svg>`,
                MIRROR_SHAPES: {
                    'N': `<path d="M0 18 L6 24 L18 24 L24 18 L24 15 L0 15 Z" />`,
                    'E': `<path d="M6 0 L0 6 L0 18 L6 24 L9 24 L9 0 Z" />`,
                    'S': `<path d="M0 6 L6 0 L18 0 L24 6 L24 9 L0 9 Z" />`,
                    'W': `<path d="M18 0 L24 6 L24 18 L18 24 L15 24 L15 0 Z" />`,
                    'NE': `<polygon points="0,0 0,24 24,24" />`,
                    'SE': `<polygon points="0,0 24,0 0,24" />`,
                    'SW': `<polygon points="0,0 24,0 24,24" />`,
                    'NW': `<polygon points="0,24 24,24 24,0" />`
                }
            },
            LASER_COLORS: {
                'Red':    '#ff0000',
                'Yellow': '#eab308',
                'Blue':   '#0000ff',
                'Green':  '#00ff00',
                'Purple': '#be00ff',
                'Orange': '#ff7f00',
                'Pink':   '#ff00bf',
                'Cyan':   '#00ffff'
            },
            APP_ID: typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'
        };
        CONSTANTS.REFLECTION_MAP = {
            'N': {
                [CONSTANTS.VECTORS.fromNW]: CONSTANTS.VECTORS.toNE,
                [CONSTANTS.VECTORS.fromN]: CONSTANTS.VECTORS.toN,
                [CONSTANTS.VECTORS.fromNE]: CONSTANTS.VECTORS.toNW,
                [CONSTANTS.VECTORS.fromE]: "DESTROY",
                [CONSTANTS.VECTORS.fromSE]: "DESTROY",
                [CONSTANTS.VECTORS.fromS]: "DESTROY",
                [CONSTANTS.VECTORS.fromSW]: "DESTROY",
                [CONSTANTS.VECTORS.fromW]: "DESTROY"
            },
            'NE': {
                [CONSTANTS.VECTORS.fromN]: CONSTANTS.VECTORS.toE,
                [CONSTANTS.VECTORS.fromNE]: CONSTANTS.VECTORS.toNE,
                [CONSTANTS.VECTORS.fromE]: CONSTANTS.VECTORS.toN,
                [CONSTANTS.VECTORS.fromSE]: "DESTROY",
                [CONSTANTS.VECTORS.fromS]: "DESTROY",
                [CONSTANTS.VECTORS.fromSW]: "DESTROY",
                [CONSTANTS.VECTORS.fromW]: "DESTROY",
                [CONSTANTS.VECTORS.fromNW]: "DESTROY"
            },
            'E': {
                [CONSTANTS.VECTORS.fromNE]: CONSTANTS.VECTORS.toSE,
                [CONSTANTS.VECTORS.fromE]: CONSTANTS.VECTORS.toE,
                [CONSTANTS.VECTORS.fromSE]: CONSTANTS.VECTORS.toNE,
                [CONSTANTS.VECTORS.fromS]: "DESTROY",
                [CONSTANTS.VECTORS.fromSW]: "DESTROY",
                [CONSTANTS.VECTORS.fromW]: "DESTROY",
                [CONSTANTS.VECTORS.fromNW]: "DESTROY",
                [CONSTANTS.VECTORS.fromN]: "DESTROY"
            },
            'SE': {
                [CONSTANTS.VECTORS.fromE]: CONSTANTS.VECTORS.toS,
                [CONSTANTS.VECTORS.fromSE]: CONSTANTS.VECTORS.toSE,
                [CONSTANTS.VECTORS.fromS]: CONSTANTS.VECTORS.toE,
                [CONSTANTS.VECTORS.fromSW]: "DESTROY",
                [CONSTANTS.VECTORS.fromW]: "DESTROY",
                [CONSTANTS.VECTORS.fromNW]: "DESTROY",
                [CONSTANTS.VECTORS.fromN]: "DESTROY",
                [CONSTANTS.VECTORS.fromNE]: "DESTROY",
            },
            'S': {
                [CONSTANTS.VECTORS.fromSE]: CONSTANTS.VECTORS.toSW,
                [CONSTANTS.VECTORS.fromS]: CONSTANTS.VECTORS.toS,
                [CONSTANTS.VECTORS.fromSW]: CONSTANTS.VECTORS.toSE,
                [CONSTANTS.VECTORS.fromW]: "DESTROY",
                [CONSTANTS.VECTORS.fromNW]: "DESTROY",
                [CONSTANTS.VECTORS.fromN]: "DESTROY",
                [CONSTANTS.VECTORS.fromNE]: "DESTROY",
                [CONSTANTS.VECTORS.fromE]: "DESTROY"
            },
            'SW': {
                [CONSTANTS.VECTORS.fromS]: CONSTANTS.VECTORS.toW,
                [CONSTANTS.VECTORS.fromSW]: CONSTANTS.VECTORS.toSW,
                [CONSTANTS.VECTORS.fromW]: CONSTANTS.VECTORS.toS,
                [CONSTANTS.VECTORS.fromNW]: "DESTROY",
                [CONSTANTS.VECTORS.fromN]: "DESTROY",
                [CONSTANTS.VECTORS.fromNE]: "DESTROY",
                [CONSTANTS.VECTORS.fromE]: "DESTROY",
                [CONSTANTS.VECTORS.fromSE]: "DESTROY"
            },
            'W': {
                [CONSTANTS.VECTORS.fromSW]: CONSTANTS.VECTORS.toNW,
                [CONSTANTS.VECTORS.fromW]: CONSTANTS.VECTORS.toW,
                [CONSTANTS.VECTORS.fromNW]: CONSTANTS.VECTORS.toSW,
                [CONSTANTS.VECTORS.fromN]: "DESTROY",
                [CONSTANTS.VECTORS.fromNE]: "DESTROY",
                [CONSTANTS.VECTORS.fromE]: "DESTROY",
                [CONSTANTS.VECTORS.fromSE]: "DESTROY",
                [CONSTANTS.VECTORS.fromS]: "DESTROY"
            },
            'NW': {
                [CONSTANTS.VECTORS.fromW]: CONSTANTS.VECTORS.toN,
                [CONSTANTS.VECTORS.fromNW]: CONSTANTS.VECTORS.toNW,
                [CONSTANTS.VECTORS.fromN]: CONSTANTS.VECTORS.toW,
                [CONSTANTS.VECTORS.fromNE]: "DESTROY",
                [CONSTANTS.VECTORS.fromE]: "DESTROY",
                [CONSTANTS.VECTORS.fromSE]: "DESTROY",
                [CONSTANTS.VECTORS.fromS]: "DESTROY",
                [CONSTANTS.VECTORS.fromSW]: "DESTROY"
            }
        }

        // ==========================================
        // 2. GLOBAL STATE
        // ==========================================
        const State = {
            db: null,
            auth: null,
            currentUser: null,
            gameId: null,
            game: null,
            playerIndex: -1,
            
            currentAction: null,
            selectedLocation: null,
            currentMirrorOrientation: 'N',

            previewNexus: null,
            previewNexusLocation: null,
            previewBuildings: [],
            previewCost: 0,
            
            subs: {
                game: null,
                online: null,
                invites: null,
                lobbyList: null
            },
            intervals: {
                heartbeat: null
            }
        };

        // ==========================================
        // 3. DOM ELEMENTS (Cached)
        // ==========================================
        const DOM = {
            $: (s) => document.querySelector(s),
            $$: (s) => document.querySelectorAll(s),
            
            // Views
            views: {
                profile: document.querySelector('#profile-view'),
                lobby: document.querySelector('#lobby-view'),
                lobbyList: document.querySelector('#lobby-list-view'),
                waitingRoom: document.querySelector('#waiting-room-view'),
                game: document.querySelector('#game-view'),
                modal: document.querySelector('#modal-view')
            },
            
            // Inputs & Dynamic Areas
            lobbyListContainer: document.querySelector('#lobby-list-container'),
            onlineLists: document.querySelectorAll('.online-players-list'),
            gameBoard: document.querySelector('#game-board'),
            gameLog: document.querySelector('#game-log'),

            // Lobby View (for name editing)
            lobbyNameDisplay: document.querySelector('#lobby-user-name-display'),
            lobbyNameEdit: document.querySelector('#lobby-user-name-edit'),
            
            // Text Displays
            userId: document.querySelector('#user-id-display'),
            userName: document.querySelector('#user-display-name-display'),
            gameId: document.querySelector('#game-id-display'),
            playerHudLabel: document.querySelector('#player-hud-label'),
            playerHudInfo: document.querySelector('#player-hud-info'),
            opponentHudLabel: document.querySelector('#opponent-hud-label'),
            opponentHudInfo: document.querySelector('#opponent-hud-info'),
            phase: document.querySelector('#current-phase'),
            energy: document.querySelector('#energy-pool'),
            budget: document.querySelector('#player-budget'),
            modalMsg: document.querySelector('#modal-message')
        };

        // ==========================================
        // 4. GAME LOGIC (Pure Functions)
        // ==========================================
        const GameLogic = {
            getUnitAt: (r, c, gameData) => {
                if (!gameData || !gameData.players) return null;
                for (let i = 0; i < gameData.players.length; i++) {
                    const p = gameData.players[i];
                    if (!p) continue;
                    // Check Nexus
                    if (p.nexusLocation && p.nexusLocation[0] === r && p.nexusLocation[1] === c) {
                        return { type: 'nexus', hp: p.nexusHP, ownerIdx: i };
                    }
                    // Check Buildings
                    const b = p.buildings.find(b => b.location[0] === r && b.location[1] === c);
                    if (b) return { ...b, ownerIdx: i };
                }
                return null;
            },

            isValidNexusMove: (startLoc, targetLoc, playerIndex, gameData) => {
                if (!startLoc || !targetLoc) return false;
                const p = gameData.players[playerIndex];
                // Use start-of-turn location for range check
                const [rS, cS] = p.nexusStartLoc || startLoc; 
                const [rT, cT] = targetLoc;

                const myZoneStart = (playerIndex === 0) ? 0 : 5;
                const myZoneEnd = (playerIndex === 0) ? 5 : CONSTANTS.BOARD_COLS;
                if (cT < myZoneStart || cT >= myZoneEnd) {
                    return false; // Out of player's zone
                }
                
                const pathDist = GameLogic.findShortestPath([rS, cS], [rT, cT], gameData);
                if (pathDist > CONSTANTS.NEXUS_RANGE) return false;

                const unit = GameLogic.getUnitAt(rT, cT, gameData);
                // Can only move to empty space or own nexus (self)
                if (unit && unit.type !== 'nexus') return false;
                if (unit && unit.type === 'nexus' && unit.ownerIdx !== playerIndex) return false;
                
                return true;
            },

            findShortestPath: (startLoc, targetLoc, gameData) => {
                const [startR, startC] = startLoc;
                const [targetR, targetC] = targetLoc;

                let queue = [[startR, startC, 0]]; // [r, c, distance]
                let visited = new Set();
                visited.add(`${startR},${startC}`);

                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // N, S, W, E

                while (queue.length > 0) {
                    const [r, c, dist] = queue.shift();

                    if (r === targetR && c === targetC)
                        return dist;

                    if (dist >= CONSTANTS.NEXUS_RANGE)
                        continue;

                    for (const [dr, dc] of directions) {
                        const nr = r + dr;
                        const nc = c + dc;
                        const key = `${nr},${nc}`;

                        if (nr < 0 || nr >= CONSTANTS.BOARD_ROWS || nc < 0 || nc >= CONSTANTS.BOARD_COLS || visited.has(key))
                            continue;

                        visited.add(key);

                        const unit = GameLogic.getUnitAt(nr, nc, gameData);
                        const isTarget = (nr === targetR && nc === targetC);

                        if (unit && !isTarget)
                            continue;
                        
                        queue.push([nr, nc, dist + 1]);
                    }
                }
                return Infinity;
            },

            traceLaser: (startLoc, direction, gameData) => {
                let [r, c] = startLoc;
                let [dx, dy] = direction;
                let path = [[r, c]];
                let hits = [];
                let log = [];
                
                // Clone game state for simulation
                const simGame = JSON.parse(JSON.stringify(gameData)); 

                for (let i = 0; i < 40; i++) { // Max steps
                    r += dx; c += dy;
                    path.push([r, c]);

                    // 1. Wall Check
                    const rOut = r < 0 || r >= CONSTANTS.BOARD_ROWS;
                    const cOut = c < 0 || c >= CONSTANTS.BOARD_COLS;

                    // STOP if hitting Back Walls (Left/Right columns)
                    if (cOut) {
                        log.push({ msg: "Laser escaped the system (MISS).", audience: "public" });
                        break; 
                    }

                    // REFLECT if hitting Side Walls (Top/Bottom rows)
                    if (rOut) {
                        // Check for perpendicular (dy === 0) vs. diagonal (dy !== 0) hit

                        if (dy === 0) { // Perpendicular hit
                            log.push({ msg: "Laser escaped the system (MISS).", audience: "public" });
                            break; // Escape the system
                        } else { // Diagonal hit
                            const [prevR, prevC] = path[path.length - 2];
                            const ownerIdx = (prevC < 5) ? 0 : 1;
                            log.push({ msg: "Laser reflected off side boundary.", audience: `p${ownerIdx}` });


                            r = prevR;
                            c = prevC + dy;

                            path[path.length - 1] = [r, c]; 

                            const cOut = c < 0 || c >= CONSTANTS.BOARD_COLS;
                            if (cOut) {
                                log.push({ msg: "Laser escaped the system (MISS).", audience: "public" });
                                break; 
                            }

                            dx = -dx; 
                            direction = [dx, dy];
                        }
                    }

                    // 2. Unit Check
                    const unit = GameLogic.getUnitAt(r, c, simGame);
                    if (unit) {
                        const ownerName = simGame.players[unit.ownerIdx].displayName;
                        if (unit.type === 'nexus') {
                            log.push({ msg: `HIT ${ownerName}'s Nexus!`, audience: "public" });
                            hits.push(unit);
                            unit.hp--;
                            break; 
                        } else if (unit.type === 'pylon') {
                            log.push({ msg: `HIT ${ownerName}'s Pylon!`, audience: "public" });
                            hits.push(unit);
                            break;
                        } else if (unit.type === 'mirror') {
                            const orientation = unit.orientation || 'N';
                            const incomingVecKey = `${dx},${dy}`;
                            const ruleSet = CONSTANTS.REFLECTION_MAP[orientation];
                            if (!ruleSet || !ruleSet[incomingVecKey]) {
                                log.push({ msg: `ERROR: Mirror ${orientation} has no rule for ${incomingVecKey}!`, audience: "public" });
                                break;
                            }
                            const result = ruleSet[incomingVecKey];
                            if (result === 'DESTROY') {
                                log.push({ msg: `HIT ${ownerName}'s Mirror!`, audience: "public" });
                                hits.push(unit);
                                break; 
                            } else {
                                log.push({ msg: `REFLECT off ${ownerName}'s Mirror!`, audience: `p${unit.ownerIdx}` });
                                [dx, dy] = result;
                                direction = [dx, dy];
                                continue;
                            }
                        }
                    }
                }
                return { path, hits, log };
            }
        };

        // ==========================================
        // 5. API LAYER (Firebase Interactions)
        // ==========================================
        const API = {
            init: async () => {
                const config = {
                    apiKey: "AIzaSyBTK04oSfdM5K0w8sspYn42OQzCGFf8AMM",
                    authDomain: "zero-sum-defense.firebaseapp.com",
                    projectId: "zero-sum-defense",
                    storageBucket: "zero-sum-defense.firebasestorage.app",
                    messagingSenderId: "484724724929",
                    appId: "1:484724724929:web:104009b0c91ee8559a3040"
                };
                const app = initializeApp(config);
                State.db = getFirestore(app);
                State.auth = getAuth(app);
                setLogLevel('error'); // Clean console

                onAuthStateChanged(State.auth, async (user) => {
                    if (user) {
                        State.currentUser = { uid: user.uid };
                        DOM.userId.textContent = user.uid;
                        await API.loadProfile();
                        // Presence starts when user clicks "multiplayer", not on auth
                    } else {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            signInWithCustomToken(State.auth, __initial_auth_token);
                        } else {
                            signInAnonymously(State.auth);
                        }
                    }
                });
            },

            loadProfile: async () => {
                try {
                    const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'users', State.currentUser.uid, 'profile', 'settings');
                    const snap = await getDoc(ref);
                    if (snap.exists()) {
                        State.currentUser.profile = snap.data();
                        DOM.userName.textContent = State.currentUser.profile.displayName;
                        DOM.$('#lobby-name-input').value = State.currentUser.profile.displayName;
                        UIManager.show('lobby');
                        API.presence.stop();
                    } else {
                        UIManager.populateColors(DOM.$('#profile-color-select'));
                        UIManager.show('profile');
                    }
                } catch(e) { console.error(e); UIManager.toast("Profile load error"); }
            },

            saveProfile: async (name, color) => {
                const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'users', State.currentUser.uid, 'profile', 'settings');
                await setDoc(ref, { displayName: name, preferredColor: color });
                await API.loadProfile(); // Reload profile to update State and UI
                // The presence heartbeat (hb) will automatically pick up the new name
            },

            presence: {
                start: () => {
                    if (State.subs.online) return; // Already started

                    const hb = () => {
                        if(!State.currentUser?.profile) return;
                        const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'online_users', State.currentUser.uid);
                        const currentStatus = State.currentUser.status || 'Available';
                        setDoc(ref, { 
                            displayName: State.currentUser.profile.displayName, 
                            lastSeen: Date.now(),
                            status: currentStatus
                        }, { merge: true });
                    };
                    hb(); 
                    // Store interval ID so we can stop it later
                    State.intervals.heartbeat = setInterval(hb, 30000);

                    const onlineRef = collection(State.db, 'artifacts', CONSTANTS.APP_ID, 'online_users');
                    State.subs.online = onSnapshot(onlineRef, (snap) => {
                        UIManager.renderOnlineList(snap);
                    });

                    API.presence.listenInvites();
                },

                stop: async () => {
                    // 1. Stop Heartbeat
                    if (State.intervals.heartbeat) clearInterval(State.intervals.heartbeat);
                    State.intervals.heartbeat = null;

                    // 2. Unsubscribe from Online List
                    if (State.subs.online) State.subs.online();
                    State.subs.online = null;

                    // 3. Unsubscribe from Invites (User won't receive invites in main menu)
                    if (State.subs.invites) State.subs.invites();
                    State.subs.invites = null;

                    // 4. Delete self from DB immediately (removes from other players' lists)
                    if (State.currentUser?.uid) {
                        const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'online_users', State.currentUser.uid);
                        await deleteDoc(ref);
                    }
                },

                setStatus: (status) => {
                    if(!State.currentUser) return;
                    State.currentUser.status = status;
                    const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'online_users', State.currentUser.uid);
                    // Use setDoc with merge to ensure we don't overwrite if it was deleted (though usually we are active)
                    setDoc(ref, { status: status, lastSeen: Date.now() }, { merge: true });
                },

                listenInvites: () => {
                    if (State.subs.invites) return;
                    const q = query(collection(State.db, 'artifacts', CONSTANTS.APP_ID, 'invites'), where("toUid", "==", State.currentUser.uid));
                    State.subs.invites = onSnapshot(q, (snap) => {
                        snap.docChanges().forEach(change => {
                            if(change.type === "added" && (Date.now() - change.doc.data().timestamp < 300000)) {
                                UIManager.showInvite(change.doc.data(), change.doc.id);
                            }
                        });
                    });
                },

                sendInvite: async (toUid, toName, gameId) => {
                    // SAFETY CHECK: Does the user still exist?
                    const targetRef = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'online_users', toUid);
                    const targetSnap = await getDoc(targetRef);

                    if (!targetSnap.exists()) {
                        throw new Error("This user is no longer online.");
                    }

                    if (!State.game) {
                        UIManager.toast("Error: Game state not found.");
                        return;
                    }
                    const ref = collection(State.db, 'artifacts', CONSTANTS.APP_ID, 'invites');
                    await addDoc(ref, {
                        toUid: toUid,
                        fromUid: State.currentUser.uid,
                        fromName: State.currentUser.profile.displayName,
                        gameId: gameId,
                        lobbyName: State.game.lobbyName,
                        timestamp: Date.now()
                    });
                    UIManager.toast(`Invite sent to ${toName}!`);
                }
            },

            lobby: {
                // MODIFIED: To return the new game ID
                create: async (name, energy, color) => {
                    const coll = collection(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games');
                    // Purge old
                    const q = query(coll, where("players", "array-contains", { userId: State.currentUser.uid })); // Simplified purge query

                    const gameData = {
                        lobbyName: name,
                        status: 'waitingForOpponent',
                        createdAt: Date.now(),
                        maxEnergy: parseInt(energy),
                        energyPool: parseInt(energy),
                        pendingEnergyRefund: 0,
                        turn: 0,
                        phase: 'setup',
                        lastShotVector: null,
                        log: [`Lobby '${name}' created.`],
                        lastUpdated: Date.now(),
                        players: [{
                            userId: State.currentUser.uid,
                            displayName: State.currentUser.profile.displayName,
                            color: color,
                            nexusLocation: null,
                            nexusHP: CONSTANTS.NEXUS_HP,
                            buildings: [],
                            isReady: false
                        }]
                    };
                    const ref = await addDoc(coll, gameData);
                    API.game.listen(ref.id);
                    return ref.id; // Return the new ID
                },
                join: async (gameId) => {
                    const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', gameId);
                    const snap = await getDoc(ref);
                    if(!snap.exists()) return UIManager.toast("Game not found");
                    const data = snap.data();
                    
                    if(data.players[0].userId === State.currentUser.uid) {
                        API.game.listen(gameId); // Re-join own game
                        return;
                    }

                    // Don't join if full
                    if (data.players.length >= 2) {
                        UIManager.toast("Lobby is full.");
                        return;
                    }
                    
                    // Logic to pick color not taken
                    let myColor = State.currentUser.profile.preferredColor;
                    if(data.players[0].color === myColor) myColor = CONSTANTS.COLORS.find(c => c !== myColor) || 'Blue';

                    const p2 = {
                        userId: State.currentUser.uid,
                        displayName: State.currentUser.profile.displayName,
                        color: myColor,
                        nexusHP: CONSTANTS.NEXUS_HP,
                        buildings: [],
                        isReady: false,
                        nexusLocation: null
                    };
                    
                    await updateDoc(ref, { 
                        players: [data.players[0], p2], 
                        status: 'waitingForHostStart',
                        lastUpdated: Date.now(),
                        log: [...data.log, `${p2.displayName} joined.`]
                    });
                    API.game.listen(gameId);
                },
                leave: async () => {
                    if(!State.gameId) return;
                    const ref = doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId);

                    if(State.game.status === 'gameOver' || State.game.players.length <= 1) {
                        await deleteDoc(ref);
                    } else {
                        // Remove self
                        const remaining = State.game.players.filter(p => p.userId !== State.currentUser.uid);
                        await updateDoc(ref, { players: remaining, status: 'waitingForOpponent' });
                    }
                    API.game.stopListening();
                    UIManager.show('lobbyList');
                },
                listenToList: () => {
                    if (State.subs.lobbyList) return;

                    DOM.lobbyListContainer.innerHTML = "<div class='text-gray-500 text-center mt-4'>Loading live lobbies...</div>";

                    const q = query(collection(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games'), where("status", "==", "waitingForOpponent"));

                    State.subs.lobbyList = onSnapshot(q, (snap) => {
                        DOM.lobbyListContainer.innerHTML = "";

                        let hasLobbies = false;
                        snap.forEach(async (docSnapshot) => {
                            const d = docSnapshot.data();
                            const createdAt = d.createdAt || 0;
                            const age = Date.now() - createdAt;

                            if (age > 300000) { // Cleanup old lobbies automatically
                                deleteDoc(docSnapshot.ref);
                                return;
                            }

                            hasLobbies = true;
                            const btn = document.createElement('div');
                            btn.className = "bg-gray-800 p-4 rounded flex justify-between items-center cursor-pointer hover:bg-gray-700 border border-indigo-500/30 animate-fade-in";
                            btn.innerHTML = `<div><div class="font-bold text-cyan-400">${d.lobbyName}</div><div class="text-xs text-gray-400">Host: ${d.players[0].displayName}</div></div><button class="bg-green-600 px-3 py-1 rounded text-white">Join</button>`;
                            btn.onclick = () => API.lobby.join(docSnapshot.id);
                            DOM.lobbyListContainer.appendChild(btn);
                        });

                        if (!hasLobbies) {
                            DOM.lobbyListContainer.innerHTML = "<div class='text-gray-500 text-center mt-4'>No active lobbies found. Create one!</div>";
                        }
                    });
                },

                stopListeningToList: () => {
                    if (State.subs.lobbyList) State.subs.lobbyList();
                    State.subs.lobbyList = null;
                },
            },

            game: {
                listen: (id) => {
                    if(State.subs.game) State.subs.game();
                    State.gameId = id;
                    DOM.gameId.textContent = id;
                    
                    State.subs.game = onSnapshot(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', id), (snap) => {
                        if(!snap.exists()) { 
                            API.game.stopListening(); 
                            UIManager.showModal("Lobby Closed", false); 
                            UIManager.show('lobbyList');
                            return; 
                        }
                        
                        const newData = snap.data();

                        const amIStillInGame = newData.players.some(p => p.userId === State.currentUser.uid);
                        
                        if (!amIStillInGame) {
                            API.game.stopListening();
                            UIManager.toast("You have been kicked by the host.");
                            UIManager.show('lobbyList');
                            return;
                        }

                        // === Local function to update state and render ===
                        const updateAndRender = (dataToRender) => {
                            if (dataToRender.lastUpdated <= State.game?.lastUpdated) { return; }

                            State.game = dataToRender; // Use the passed-in data
                            State.playerIndex = State.game.players.findIndex(p => p.userId === State.currentUser.uid);

                            if(State.game.status === 'inProgress' || State.game.status === 'gameOver') {
                                UIManager.show('game');
                                UIManager.renderGame();
                            } else {
                                UIManager.show('waitingRoom');
                                UIManager.renderWaitingRoom();
                            }
                        };

                        // === NEW ANIMATION TRIGGER ===
                        const needsAnimation = newData.lastLaserPath && newData.lastAttackId && 
                                               (newData.lastAttackId !== State.game?.lastAttackId);

                        if (needsAnimation) {
                            const pathArray = JSON.parse(newData.lastLaserPath);
                            const shooterIndex = (newData.turn + 1) % 2;
                            const shooterColor = newData.players[shooterIndex] ? newData.players[shooterIndex].color : 'Red';

                            // Play animation *first*, using the OLD state.
                            // Then, in the callback, update the state and render.
                            UIManager.animateLaser(pathArray, shooterColor, () => updateAndRender(newData));
                        } else {
                            // =============================
                            // No animation, just update immediately
                            updateAndRender(newData);
                        }
                    });
                },
                stopListening: () => {
                    if(State.subs.game) State.subs.game();
                    State.gameId = null;
                    State.game = null;
                    API.presence.setStatus('Available');
                },
                
                // --- Actions ---
                toggleReady: async () => {
                    const newP = [...State.game.players];
                    newP[State.playerIndex].isReady = !newP[State.playerIndex].isReady;
                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        players: newP,
                        lastUpdated: Date.now()
                    });
                },
                startGame: async () => {
                    // 1. Deep Reset of Players (keep ID/Name/Color/Ready, wipe board data)
                    const resetPlayers = State.game.players.map(p => ({
                        userId: p.userId,
                        displayName: p.displayName,
                        color: p.color,
                        isReady: p.isReady, // Keep ready state or reset? usually keep until game actually inits
                        nexusLocation: null,
                        nexusStartLoc: null,
                        nexusHP: CONSTANTS.NEXUS_HP,
                        buildings: []
                    }));

                    // 2. Push Full Reset Update
                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        status: 'inProgress', 
                        phase: 'setup', 
                        turn: 0, 
                        energyPool: State.game.maxEnergy,
                        pendingEnergyRefund: 0,
                        lastShotVector: null,
                        lastLaserPath: null,
                        lastAttackId: null,
                        turnBudget: 0,
                        players: resetPlayers,
                        lastUpdated: Date.now(),
                        log: [`Game Started! State Reset.`]
                    });
                },
                placeNexus: async (loc) => {
                    const newP = JSON.parse(JSON.stringify(State.game.players));
                    newP[State.playerIndex].nexusLocation = loc;
                    newP[State.playerIndex].nexusStartLoc = loc;
                    
                    let updates = { players: newP, log: [...State.game.log, "Nexus Placed."] };
                    updates.lastUpdated = Date.now();
                    
                    // Check if both ready
                    const p1 = newP[0], p2 = newP[1];
                    if(p1.nexusLocation && (newP.length === 1 || p2?.nexusLocation)) {
                        updates.status = 'inProgress';
                        updates.phase = 'buyMove';
                        const newEnergyPool = State.game.maxEnergy;
                        updates.energyPool = newEnergyPool;
                        // Player 0 (turn 0) has 0 pylons. Budget = min(0 + 1, energyPool)
                        updates.turnBudget = Math.min(1, newEnergyPool);
                        updates.log.push("All Nexus placed. Phase: Buy/Move");
                    }
                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), updates);
                },
                confirmBuyMovePhase: async (buildingsToPlace, nexusMoveLocation) => {
                    const newP = JSON.parse(JSON.stringify(State.game.players));
                    const myP = newP[State.playerIndex];

                    let totalCost = 0;
                    let newLogs = [...State.game.log];
                    if (nexusMoveLocation) {
                        myP.nexusLocation = nexusMoveLocation;
                        newLogs.push(`Nexus moved.`);
                    }

                    buildingsToPlace.forEach(b => {
                        const newBuilding = { type: b.type, location: b.location, hp: CONSTANTS.BUILDING_HP };
                        if (b.type === 'mirror') {
                            newBuilding.orientation = b.orientation || 'N';
                            newLogs.push(`Placed ${newBuilding.orientation} Mirror.`);
                        } else {
                            newLogs.push(`Placed ${b.type}.`);
                        }
                        myP.buildings.push(newBuilding);
                        totalCost += 1; // Assuming all cost 1
                    });

                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        players: newP,
                        energyPool: State.game.energyPool - totalCost,
                        turnBudget: State.game.turnBudget - totalCost,
                        phase: 'attack',
                        lastUpdated: Date.now(),
                        log: [...newLogs, "Attack Phase."]
                    });
                },
                // moveNexus: async (to) => {
                //     const newP = JSON.parse(JSON.stringify(State.game.players));
                //     newP[State.playerIndex].nexusLocation = to;
                //     await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                //         players: newP,
                //         log: [...State.game.log, "Nexus Moved."]
                //     });
                // },
                endPhase: async () => {
                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        phase: 'attack',
                        lastUpdated: Date.now(),
                        log: [...State.game.log, "Attack Phase."]
                    });
                },
                attack: async (dx, dy) => {
                    try {
                        const startLoc = State.game.players[State.playerIndex].nexusLocation;
                        const { path, hits, log } = GameLogic.traceLaser(startLoc, [dx, dy], State.game);
                        
                        // Apply Damage
                        const newP = JSON.parse(JSON.stringify(State.game.players));
                        let destroyedCount = 0;
                        let gameOver = false;
                        let winner = -1;

                        hits.forEach(h => {
                            if (h.type === 'nexus') {
                                newP[h.ownerIdx].nexusHP--;
                                if(newP[h.ownerIdx].nexusHP <= 0) { gameOver = true; winner = (h.ownerIdx + 1) % 2; }
                            } else {
                                newP[h.ownerIdx].buildings = newP[h.ownerIdx].buildings.filter(b => 
                                    !(b.location[0] === h.location[0] && b.location[1] === h.location[1])
                                );
                                destroyedCount++;
                            }
                        });

                        const nextTurn = (State.game.turn + 1) % 2;
                        // Apply refunds
                        const nextPool = State.game.energyPool + State.game.pendingEnergyRefund;

                        // Calculate next player's budget
                        const nextPlayer = newP[nextTurn];
                        const nextPlayerPylons = nextPlayer?.buildings ? nextPlayer.buildings.filter(b => b.type === 'pylon').length : 0;
                        const newTurnBudget = Math.min(nextPlayerPylons + 1, nextPool);
                        
                        if(nextPlayer?.nexusLocation) nextPlayer.nexusStartLoc = nextPlayer.nexusLocation;

                        let updates = {
                            players: newP,
                            log: [...State.game.log, ...log],
                            lastShotVector: [dx, dy],
                            lastLaserPath: JSON.stringify(path),
                            lastAttackId: Date.now(),
                            lastUpdated: Date.now(),
                            turn: nextTurn,
                            phase: 'buyMove',
                            energyPool: nextPool,
                            turnBudget: newTurnBudget,
                            pendingEnergyRefund: destroyedCount
                        };
                        
                        if(gameOver) {
                            updates.status = 'gameOver';
                            updates.winner = winner;
                            updates.log.push("GAME OVER!");
                        }

                        await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), updates);
                        
                    } catch (err) {
                        console.error("Attack Error:", err);
                        UIManager.toast("Error attacking: " + err.message);
                    }
                },
                skipAttack: async () => {
                    const nextTurn = (State.game.turn + 1) % 2;
                    const newP = JSON.parse(JSON.stringify(State.game.players));
                    const nextPlayer = newP[nextTurn];
                    if(nextPlayer?.nexusLocation) nextPlayer.nexusStartLoc = nextPlayer.nexusLocation;
                    
                    const newEnergyPool = State.game.energyPool + State.game.pendingEnergyRefund;
                    const nextPlayerPylons = nextPlayer?.buildings ? nextPlayer.buildings.filter(b => b.type === 'pylon').length : 0;
                    const newTurnBudget = Math.min(nextPlayerPylons + 1, newEnergyPool);

                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        turn: nextTurn,
                        phase: 'buyMove',
                        energyPool: newEnergyPool,
                        turnBudget: newTurnBudget,
                        pendingEnergyRefund: 0,
                        lastShotVector: null,
                        lastLaserPath: null,
                        lastAttackId: null,
                        players: newP,
                        lastUpdated: Date.now(),
                        log: [...State.game.log, "Attack Skipped."]
                    });
                },
                cancelAttack: async () => {
                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        phase: 'buyMove',
                        lastUpdated: Date.now(),
                        log: [...State.game.log, "Attack canceled."]
                    });
                },
                commitAndEndTurn: async (buildingsToPlace, nexusMoveLocation) => {
                    const newP = JSON.parse(JSON.stringify(State.game.players));
                    const myP = newP[State.playerIndex];
                    let newLogs = [...State.game.log];
                    let totalCost = 0;

                    // 1. Apply Previews
                    if (nexusMoveLocation) {
                        myP.nexusLocation = nexusMoveLocation;
                        newLogs.push(`Nexus moved.`);
                    }
                    buildingsToPlace.forEach(b => {
                        const newBuilding = { type: b.type, location: b.location, hp: CONSTANTS.BUILDING_HP };
                        if (b.type === 'mirror') {
                            newBuilding.orientation = b.orientation || 'N';
                            newLogs.push(`Placed ${newBuilding.orientation} Mirror.`);
                        } else {
                            newLogs.push(`Placed ${b.type}.`);
                        }
                        myP.buildings.push(newBuilding);
                        totalCost += 1;
                    });
                    if (buildingsToPlace.length > 0) {
                        newLogs.push(`Buildings placed. Total cost: ${totalCost}`);
                    }
                    newLogs.push(`${myP.displayName} skipped the attack phase.`);

                    // 2. End Turn Logic (from skipAttack)
                    const nextTurn = (State.game.turn + 1) % 2;
                    const nextPlayer = newP[nextTurn];
                    if(nextPlayer?.nexusLocation) nextPlayer.nexusStartLoc = nextPlayer.nexusLocation;

                    const newEnergyPool = (State.game.energyPool - totalCost) + State.game.pendingEnergyRefund;
                    const nextPlayerPylons = nextPlayer?.buildings ? nextPlayer.buildings.filter(b => b.type === 'pylon').length : 0;
                    const newTurnBudget = Math.min(nextPlayerPylons + 1, newEnergyPool);

                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        turn: nextTurn,
                        phase: 'buyMove',
                        energyPool: newEnergyPool,
                        turnBudget: newTurnBudget,
                        pendingEnergyRefund: 0, 
                        lastShotVector: null,
                        lastLaserPath: null,
                        lastAttackId: null,
                        players: newP,
                        lastUpdated: Date.now(),
                        log: newLogs
                    });
                },

                updateSettings: async (newName, newEnergy) => {
                    if (State.playerIndex !== 0) return; // Host only

                    const newP = JSON.parse(JSON.stringify(State.game.players));
                    let newLogs = [...State.game.log];

                    if (newP[1]) {
                        newP[1].isReady = false; // Un-ready the guest
                        newLogs.push("Host changed settings. Guest un-readied.");
                    } else {
                        newLogs.push("Host changed settings.");
                    }

                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        lobbyName: newName,
                        maxEnergy: parseInt(newEnergy),
                        energyPool: parseInt(newEnergy), // Also update the pool to match
                        players: newP,
                        lastUpdated: Date.now(),
                        log: newLogs
                    });
                },

                kickGuest: async () => {
                    if (State.playerIndex !== 0 || State.game.players.length < 2) return; // Host only

                    const hostPlayer = State.game.players[0];
                    hostPlayer.isReady = false; // Reset host ready state

                    await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), {
                        players: [hostPlayer], // Set players array to only host
                        status: 'waitingForOpponent',
                        lastUpdated: Date.now(),
                        log: [...State.game.log, `${State.game.players[1].displayName} was kicked by the host.`]
                    });
                }
            }
        };

        // ==========================================
        // 6. UI MANAGER (Rendering)
        // ==========================================
        const UIManager = {
            show: (viewName) => {
                Object.values(DOM.views).forEach(v => v.classList.add('hidden'));
                if(DOM.views[viewName]) DOM.views[viewName].classList.remove('hidden');
                
                // Update presence status based on view
                if(viewName === 'lobbyList') API.presence.setStatus('Available');
                else if (viewName === 'game' || viewName === 'waitingRoom') API.presence.setStatus('Busy');
                // Note: 'lobby' (main menu) does not set a status
            },
            toast: (msg) => {
                const el = document.createElement('div');
                el.className = 'absolute top-5 right-5 bg-indigo-600 text-white p-3 rounded shadow-lg z-50';
                el.textContent = msg;
                document.body.appendChild(el);
                setTimeout(() => el.remove(), 3000);
            },
            showError: (msg) => {
                const el = document.createElement('div');
                el.className = 'absolute top-5 right-5 bg-red-600 text-white p-3 rounded shadow-lg z-50';
                el.textContent = msg;
                document.body.appendChild(el);
                setTimeout(() => el.remove(), 3000);
            },
            showModal: (msg, isEndGame) => {
                DOM.modalMsg.innerHTML = `<p>${msg}</p>`;
                // Clear old dynamic buttons
                DOM.$$('.modal-dynamic-btn').forEach(btn => btn.remove());
                
                DOM.$('#new-game-btn').classList.toggle('hidden', !isEndGame);
                DOM.views.modal.classList.remove('hidden');
            },
            populateColors: (select) => {
                select.innerHTML = '';
                CONSTANTS.COLORS.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c; opt.textContent = c;
                    select.appendChild(opt);
                });
            },
            renderOnlineList: (snap) => {
                DOM.onlineLists.forEach(list => list.innerHTML = '');
                snap.forEach(doc => {
                    const d = doc.data();
                    if (Date.now() - d.lastSeen > 120000 || doc.id === State.currentUser.uid) return;
                    
                    const isBusy = d.status === 'Busy';
                    const statusText = isBusy ? "In Game" : "Available";
                    const statusColor = isBusy ? "text-red-400" : "text-green-400";

                    const el = document.createElement('div');
                    el.className = 'flex justify-between items-center p-2 bg-gray-800 rounded mb-1';
                    el.innerHTML = `
                        <div>
                            <span>${d.displayName}</span>
                            <span class="ml-2 text-xs ${statusColor}">(${statusText})</span>
                        </div>
                        <button 
                            data-uid="${doc.id}" 
                            data-name="${d.displayName}"
                            class="invite-btn bg-cyan-600 hover:bg-cyan-500 disabled:bg-gray-600 disabled:opacity-50 text-white text-xs px-2 py-1 rounded"
                            ${isBusy ? 'disabled' : ''}
                        >
                            Invite
                        </button>
                    `;
                    DOM.onlineLists.forEach(list => list.appendChild(el.cloneNode(true)));
                });
            },
            // MODIFIED: To show more invite info
            showInvite: (data, id) => {
                DOM.modalMsg.innerHTML = `
                    <p class="text-2xl mb-2">Game Invite!</p>
                    <p class="text-lg mb-1">From: <span class="font-bold text-cyan-400">${data.fromName}</span></p>
                    <p class="text-sm mb-4">Lobby: <span class="font-bold text-gray-300">${data.lobbyName}</span></p>
                `;
                
                // Add Accept/Decline buttons
                const btnContainer = document.createElement('div');
                btnContainer.className = "flex gap-4 justify-center mt-6 modal-dynamic-btn";

                const acceptBtn = document.createElement('button');
                acceptBtn.className = "bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-6 rounded-lg";
                acceptBtn.textContent = "Accept";
                acceptBtn.onclick = () => { 
                    deleteDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'invites', id));
                    API.lobby.join(data.gameId);
                    DOM.views.modal.classList.add('hidden');
                };

                const declineBtn = document.createElement('button');
                declineBtn.className = "bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg";
                declineBtn.textContent = "Decline";
                declineBtn.onclick = () => { 
                    deleteDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'invites', id));
                    DOM.views.modal.classList.add('hidden');
                };
                
                btnContainer.appendChild(declineBtn);
                btnContainer.appendChild(acceptBtn);
                DOM.modalMsg.appendChild(btnContainer);

                DOM.$('#new-game-btn').classList.add('hidden'); // Hide default button
                DOM.views.modal.classList.remove('hidden');
            },
            
            renderWaitingRoom: () => {
                const g = State.game;
                const p1 = g.players[0];
                const p2 = g.players[1];
                const isHost = State.playerIndex === 0;

                // === Host Settings Panel ===
                const hostPanel = DOM.$('#host-settings-panel');
                const lobbyNameInput = DOM.$('#waiting-lobby-name-input');
                const energySelect = DOM.$('#waiting-energy-pool-select');

                if (isHost) {
                    hostPanel.classList.remove('hidden');
                    lobbyNameInput.disabled = false;
                    energySelect.disabled = false;
                    
                    lobbyNameInput.value = g.lobbyName;
                    energySelect.value = g.maxEnergy;

                    // Add event listeners that update settings and un-ready P2
                    lobbyNameInput.onchange = (e) => {
                        API.game.updateSettings(e.target.value, energySelect.value);
                    };
                    energySelect.onchange = (e) => {
                        API.game.updateSettings(lobbyNameInput.value, e.target.value);
                    };

                } else {
                    // Guest just sees the panel, but disabled
                    hostPanel.classList.remove('hidden');
                    lobbyNameInput.value = g.lobbyName;
                    energySelect.value = g.maxEnergy;
                    lobbyNameInput.disabled = true;
                    energySelect.disabled = true;
                }

                DOM.$('#waiting-lobby-name').textContent = g.lobbyName;

                // Helper to render player box
                const renderBox = (p, prefix, isMe) => {
                    const nameEl = DOM.$(`#${prefix}-name`);
                    const rInd = DOM.$(`#${prefix}-ready-indicator`);
                    const sel = DOM.$(`#${prefix}-color-select`);
                    
                    const kickBtn = DOM.$('#kick-p2-btn');
                    
                    DOM.$(`#${prefix}-ready-btn`).classList.add('hidden');

                    if(!p) {
                        nameEl.textContent = "Empty"; 
                        nameEl.classList.add('text-gray-500');
                        rInd.classList.add('hidden'); 
                        sel.classList.add('hidden');
                        if (prefix === 'p2') kickBtn.classList.add('hidden'); // Hide kick button if no P2
                        return;
                    }

                    nameEl.textContent = p.displayName + (isMe ? " (You)" : "");
                    nameEl.classList.remove('text-gray-500');
                    
                    if (prefix === 'p1') {
                        rInd.textContent = "HOST";
                        rInd.className = "mt-2 text-xs font-bold text-cyan-500 uppercase tracking-widest";
                    } else {
                        rInd.classList.remove('hidden');
                        rInd.textContent = p.isReady ? "READY" : "NOT READY";
                        rInd.className = p.isReady ? "mt-2 text-xs font-bold text-green-500 uppercase tracking-widest" : "mt-2 text-xs font-bold text-red-500 uppercase tracking-widest";

                        // Show/bind kick button
                        if (isHost) {
                            kickBtn.classList.remove('hidden');
                            kickBtn.onclick = API.game.kickGuest;
                        } else {
                            kickBtn.classList.add('hidden');
                        }
                    }
                    
                    sel.classList.remove('hidden');
                    if (sel.options.length === 0) UIManager.populateColors(sel);
                    sel.value = p.color;
                    sel.disabled = !isMe;
                    if(isMe) {
                        sel.onchange = async (e) => {
                            const newP = [...State.game.players];
                            newP[State.playerIndex].color = e.target.value;
                            await updateDoc(doc(State.db, 'artifacts', CONSTANTS.APP_ID, 'public', 'data', 'zero_sum_games', State.gameId), { players: newP });
                        };
                    }
                };
                
                renderBox(p1, 'p1', State.playerIndex === 0);
                renderBox(p2, 'p2', State.playerIndex === 1);
                
                // Main Button Logic
                const mainBtn = DOM.$('#start-game-btn');
                
                if(isHost) {
                    // Host Logic: Start Game
                    const p2Ready = p2 && p2.isReady;
                    mainBtn.textContent = p2Ready ? "Start Game" : (p2 ? "Waiting for Guest..." : "Waiting for Player...");
                    mainBtn.disabled = !p2Ready;
                    mainBtn.onclick = API.game.startGame;
                    
                    mainBtn.className = `w-full font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg mb-3 ${p2Ready ? 'bg-green-600 hover:bg-green-500 text-white cursor-pointer' : 'bg-gray-700 text-gray-400 cursor-not-allowed opacity-75'}`;
                } else if (State.playerIndex === 1) { // Check if guest
                    // Guest Logic: Toggle Ready
                    const amIReady = g.players[State.playerIndex].isReady;
                    mainBtn.textContent = amIReady ? "Cancel Ready" : "Ready Up";
                    mainBtn.disabled = false;
                    mainBtn.onclick = API.game.toggleReady;

                    mainBtn.className = `w-full font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg mb-3 cursor-pointer ${amIReady ? 'bg-yellow-600 hover:bg-yellow-500 text-white' : 'bg-green-600 hover:bg-green-500 text-white'}`;
                } else {
                    mainBtn.classList.add('hidden');
                }
            },
            
            renderGame: () => {
                if (State.game.phase !== 'buyMove' || State.game.turn !== State.playerIndex) {
                    State.previewBuildings = [];
                    State.previewCost = 0;
                    State.previewNexusLocation = null;
                    State.currentAction = null;
                }

                const g = State.game;
                const myP = g.players[State.playerIndex];
                if(!myP) return; 
                
                const turnP = g.players[g.turn];
                
                const getTextColor = (colorName) => {
                    const c = CONSTANTS.COLOR_MAP[colorName];
                    return (c && c.text) ? c.text : 'text-white';
                };

                const opponentP = g.players[(State.playerIndex + 1) % 2];
                const isMyTurn = g.turn === State.playerIndex;

                // 1. Set Your Info
                const myColorClass = getTextColor(myP.color);
                DOM.playerHudInfo.innerHTML = `<span class="${myColorClass}">${myP.displayName} (HP: ${myP.nexusHP})</span>`;

                // 2. Set Opponent Info
                if(opponentP) {
                    const oppColorClass = getTextColor(opponentP.color);
                    DOM.opponentHudInfo.innerHTML = `<span class="${oppColorClass}">${opponentP.displayName} (HP: ${opponentP.nexusHP})</span>`;
                } else {
                    DOM.opponentHudInfo.innerHTML = `<span class="text-gray-500">Waiting... (HP: --)</span>`;
                }
                // 3. Set Turn Indicator
                if(isMyTurn) {
                    DOM.playerHudLabel.textContent = "Current Turn";
                    DOM.playerHudLabel.className = "text-xs text-yellow-300 animate-pulse block";
                    DOM.opponentHudLabel.textContent = "Opponent";
                    DOM.opponentHudLabel.className = "text-xs text-gray-400 block";
                } else {
                    DOM.playerHudLabel.textContent = "You Are";
                    DOM.playerHudLabel.className = "text-xs text-gray-400 block";
                    DOM.opponentHudLabel.textContent = "Current Turn";
                    DOM.opponentHudLabel.className = "text-xs text-yellow-300 animate-pulse block";
                }

                DOM.phase.textContent = g.phase;
                DOM.energy.textContent = g.energyPool;
                
                // Calc Budget
                const budget = (g.turn === State.playerIndex && g.phase === 'buyMove') ? (g.turnBudget || 0) : 0;
                const availableBudget = budget - State.previewCost;
                DOM.budget.textContent = availableBudget;
                
                // Render sub-components
                UIManager.renderBoard(); // Will use preview state
                UIManager.renderControls(availableBudget);
                
                // Render Log
                if(DOM.gameLog && g.log) {
                    const myAudience = `p${State.playerIndex}`;
                    const filteredLog = g.log.slice().reverse().map(logEntry => {
                        if (typeof logEntry === 'string') {
                            return `<div class="border-b border-gray-700 py-1">${logEntry}</div>`;
                        }

                        // Handle new log objects
                        const audience = logEntry.audience;

                        if (audience === 'public' || audience === myAudience) {
                            return `<div class="border-b border-gray-700 py-1">${logEntry.msg}</div>`;
                        }
                        return null;
                    }).filter(Boolean);
                    DOM.gameLog.innerHTML = filteredLog.join('');
                }
                if(g.status === 'gameOver') UIManager.showModal(`Game Over! Winner: ${g.players[g.winner].displayName}`, true);
            },
            
            renderBoard: () => {
                const g = State.game;
                DOM.gameBoard.innerHTML = '';
                const myZoneStart = State.playerIndex === 0 ? 0 : 5;
                const myZoneEnd = State.playerIndex === 0 ? 5 : 10;

                for(let r=0; r<CONSTANTS.BOARD_ROWS; r++){
                    for(let c=0; c<CONSTANTS.BOARD_COLS; c++){
                        const cell = document.createElement('div');
                        cell.className = 'relative aspect-square border border-indigo-500/30 transition-all duration-150';
                        cell.dataset.r = r; cell.dataset.c = c;

                        const isMyZone = c >= myZoneStart && c < myZoneEnd;
                        if(isMyZone) cell.classList.add(CONSTANTS.COLOR_MAP[g.players[State.playerIndex].color].bg);
                        else cell.classList.add('bg-gray-800/50'); // Shroud style

                        // --- New Render Logic (Handles Previews) ---

                        let unit = GameLogic.getUnitAt(r, c, g);
                        let unitToRender = unit;
                        let isPreview = false;
                        const previewBuilding = State.previewBuildings.find(b => b.location[0] === r && b.location[1] === c);

                        // Check if we're rendering my nexus AND there's a preview move
                        if (unit && unit.type === 'nexus' && unit.ownerIdx === State.playerIndex && State.previewNexusLocation) {
                            // This is the nexus at its *original* spot, but we have a preview move. Hide it.
                            unitToRender = null; 
                        }

                        // 1. Check for preview buildings if cell is empty
                        if (!unit) {
                            if (previewBuilding) {
                                unitToRender = { ...previewBuilding, ownerIdx: State.playerIndex, hp: 1 }; // Mock unit
                                isPreview = true;
                            }
                        }

                        // 2a. Check for preview nexus move in BUYMOVE phase
                        if (!unit && !previewBuilding && State.game.phase === 'buyMove') {
                             if (State.previewNexusLocation && State.previewNexusLocation[0] === r && State.previewNexusLocation[1] === c) {
                                 unitToRender = { type: 'nexus', ownerIdx: State.playerIndex, hp: CONSTANTS.NEXUS_HP };
                                 isPreview = true;
                             }
                        }

                        // 2b. Check for preview nexus in SETUP phase
                        if (!unit && !unitToRender && State.currentAction === 'setup') {
                            if (State.previewNexus && State.previewNexus[0] === r && State.previewNexus[1] === c) {
                                unitToRender = { type: 'nexus', ownerIdx: State.playerIndex, hp: CONSTANTS.NEXUS_HP };
                                isPreview = true;
                            }
                        }

                        // 3. Render the unit (real or preview)
                        if(unitToRender) {
                            if(isMyZone || unitToRender.ownerIdx === State.playerIndex) { // Simple FOW
                                const color = CONSTANTS.COLOR_MAP[g.players[unitToRender.ownerIdx].color];

                                let svg;
                                if (unitToRender.type === 'nexus') {
                                    svg = CONSTANTS.SVGS.NEXUS;
                                } else if (unitToRender.type === 'pylon') {
                                    svg = CONSTANTS.SVGS.PYLON;
                                } else if (unitToRender.type === 'mirror') {
                                    const orientation = unitToRender.orientation || 'N';
                                    const shape = CONSTANTS.SVGS.MIRROR_SHAPES[orientation];
                                    svg = `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${shape}</svg>`;
                                }

                                const maxHp = unitToRender.type === 'nexus' ? CONSTANTS.NEXUS_HP : CONSTANTS.BUILDING_HP;
                                // Add "PREVIEW" text and opacity for previewed units
                                const hpDisplay = (isPreview) ? `<div class="absolute bottom-0 right-0 text-[10px] bg-black/80 px-1 text-blue-300">PREVIEW</div>` : `<div class="absolute bottom-0 right-0 text-[10px] bg-black/80 px-1 text-white">${unitToRender.hp}/${maxHp}</div>`;
                                const previewClass = (isPreview) ? 'opacity-75' : '';
                                
                                cell.innerHTML = `<div class="absolute inset-0 p-1 ${color.stroke} ${color.bg} ${previewClass}">${svg}</div>${hpDisplay}`;
                            }
                        }

                        // 4. Interaction Highlights
                        if(State.currentAction === 'setup' && isMyZone && !unit) cell.classList.add('cursor-pointer', 'hover:bg-white/20');
                        // Check for !unitToRender to prevent highlighting occupied preview cells
                        if(State.currentAction === 'place-pylon' && isMyZone && !unit && !unitToRender) cell.classList.add('cursor-pointer', 'hover:bg-cyan-500/50');
                        if(State.currentAction === 'place-mirror' && isMyZone && !unit && !unitToRender) cell.classList.add('cursor-pointer', 'hover:bg-purple-500/50');
                        if(State.currentAction === 'move-nexus-target') {
                            // Check against real units, not preview buildings
                            const isBlocked = GameLogic.getUnitAt(r, c, g); 
                            if(!isBlocked && GameLogic.isValidNexusMove(State.selectedLocation, [r,c], State.playerIndex, g)) {
                                cell.classList.add('cursor-pointer', 'bg-yellow-500/30', 'animate-pulse');
                            }
                        }
                        // --- End New Render Logic ---

                        cell.onclick = () => Handlers.boardClick(r, c);
                        DOM.gameBoard.appendChild(cell);
                    }
                }
            },

            renderControls: (availableBudget) => {
                const g = State.game;
                const isMyTurn = g.turn === State.playerIndex;
                const controls = { 
                    setup: DOM.$('#setup-controls'), 
                    buy: DOM.$('#buy-move-controls'), 
                    attack: DOM.$('#attack-controls'), 
                    waiting: DOM.$('#waiting-controls') 
                };
                
                Object.values(controls).forEach(el => {
                    if(el) el.classList.add('hidden');
                });

                const oldMsg = DOM.$('#setup-waiting-msg');
                if (oldMsg) oldMsg.classList.add('hidden');

                if(g.phase === 'setup') {
                    if(!g.players[State.playerIndex].nexusLocation) {
                        if(controls.setup) controls.setup.classList.remove('hidden');
                        // Req #1: Nexus Placement requires confirmation
                        State.currentAction = 'setup'; 
                        
                        const btn = DOM.$('#confirm-nexus-btn');
                        if(btn) {
                            // Enable button as soon as a preview is set
                            btn.disabled = !State.previewNexus; 
                            btn.textContent = State.previewNexus ? "Confirm Location" : "Select Cell";
                            // The handler will now use State.previewNexus
                            btn.onclick = () => API.game.placeNexus(State.previewNexus); 
                        }
                    } else {
                        if(controls.waiting) controls.waiting.classList.remove('hidden');
                    }
                }
                else if (!isMyTurn) { 
                    if(controls.waiting) controls.waiting.classList.remove('hidden'); 
                }
                else if (g.phase === 'buyMove') {
                    if(controls.buy) controls.buy.classList.remove('hidden');
                    
                    const btnPylon = DOM.$('#place-pylon-btn');
                    const btnMirror = DOM.$('#place-mirror-btn');
                    const btnMoveNexus = DOM.$('#move-nexus-btn');
                    if (State.currentAction === 'move-nexus-target') {
                        btnMoveNexus.textContent = "Done";
                        btnMoveNexus.classList.add('bg-yellow-500');
                        btnMoveNexus.classList.remove('bg-yellow-600', 'hover:bg-yellow-500');
                    } else {
                        btnMoveNexus.textContent = "Move Nexus";
                        btnMoveNexus.classList.remove('bg-yellow-500');
                        btnMoveNexus.classList.add('bg-yellow-600', 'hover:bg-yellow-500');
                    }
                    const btnUndo = DOM.$('#undo-action-btn'); // New ID
                    const mirrorControls = DOM.$('#mirror-rotation-controls');
                    const separator = DOM.$('#buy-move-separator');
                    
                    // Req #3: Show/Hide Mirror Controls
                    if (State.currentAction === 'place-mirror') {
                        mirrorControls.classList.remove('hidden');
                    } else {
                        mirrorControls.classList.add('hidden');
                    }
                }
                else if (g.phase === 'attack') {
                    if(controls.attack) controls.attack.classList.remove('hidden');

                    let disabledDir = null;
                    const myNexusLoc = State.game.players[State.playerIndex]?.nexusLocation;
                    const lastPathStr = State.game.lastLaserPath;

                    if (myNexusLoc && lastPathStr) {
                        try {
                            const path = JSON.parse(lastPathStr);
                            const myR = myNexusLoc[0];
                            const myC = myNexusLoc[1];

                            const nexusIndexInPath = path.findIndex(loc => loc[0] === myR && loc[1] === myC);
                            if (nexusIndexInPath > 0) {
                                const prevCell = path[nexusIndexInPath - 1];
                                const incomingVec = [myR - prevCell[0], myC - prevCell[1]];
                                const returnVec = [incomingVec[0] * -1, incomingVec[1] * -1];
                                disabledDir = Object.keys(CONSTANTS.DIRECTIONS).find(key => {
                                    const dirVec = CONSTANTS.DIRECTIONS[key];
                                    return dirVec[0] === returnVec[0] && dirVec[1] === returnVec[1];
                                });
                            }
                        } catch (e) {
                            console.error("Failed to parse lastLaserPath", 0);
                        }

                    DOM.$$('button[data-dir]').forEach(btn => {
                            if (btn.dataset.dir === disabledDir) {
                                btn.disabled = true;
                                btn.classList.add('opacity-30', 'bg-gray-700', 'cursor-not-allowed');
                                btn.classList.remove('bg-red-800', 'hover:bg-red-700');
                            } else {
                                btn.disabled = false;
                                btn.classList.remove('opacity-30', 'bg-gray-700', 'cursor-not-allowed');
                                btn.classList.add('bg-red-800', 'hover:bg-red-700');
                            }
                        });
                    }
                }
            },
            
            animateLaser: (path, colorName, onCompleteCallback) => {
                const hex = CONSTANTS.LASER_COLORS[colorName] || '#ff0000';

                DOM.$$('.laser-beam-svg').forEach(el => el.remove());
                DOM.$$('.laser-active').forEach(el => el.classList.remove('laser-active'));

                const myZoneStart = State.playerIndex === 0 ? 0 : 5;
                const myZoneEnd = State.playerIndex === 0 ? 5 : CONSTANTS.BOARD_COLS;

                const getEdgeCoords = (dr, dc) => {
                    if (dr === 0 && dc === 1) return ["0%", "50%"]; // from W
                    if (dr === 0 && dc === -1) return ["100%", "50%"]; // from E
                    if (dr === 1 && dc === 0) return ["50%", "0%"]; // from N
                    if (dr === -1 && dc === 0) return ["50%", "100%"]; // from S
                    if (dr === 1 && dc === 1) return ["0%", "0%"]; // from NW
                    if (dr === 1 && dc === -1) return ["100%", "0%"]; // from NE
                    if (dr === -1 && dc === 1) return ["0%", "100%"]; // from SW
                    if (dr === -1 && dc === -1) return ["100%", "100%"]; // from SE
                    return ["50%", "50%"];
                };

                let i = 0;
                const pulseSpeed = '0.5s';
                const pulseDelayStep = 0.05;
                const interval = setInterval(() => {
                    if(i >= path.length) { 
                        clearInterval(interval); // Stop the "in" animation

                        // Start the "out" animation
                        let j = 0;
                        const fadeInterval = setInterval(() => {
                            const segment = DOM.$(`[data-laser-step="${j}"]`);
                            if (segment) segment.remove();

                            j++;

                            if (j >= path.length) {
                                clearInterval(fadeInterval); // Stop the "out" animation
                                if (onCompleteCallback) onCompleteCallback(); // Update the board
                            }
                        }, 120);

                        return;
                    }

                    const [r, c] = path[i];
                    const prev = path[i-1];
                    const next = (i + 1 < path.length) ? path[i+1] : null;

                    const isMySide = (c >= myZoneStart && c < myZoneEnd);
                    if (isMySide) {
                        const cell = DOM.$(`[data-r="${r}"][data-c="${c}"]`);

                        if(cell) { 
                            cell.style.setProperty('--laser-color', hex);
                            let svgHTML = '';
                            if (i === 0 && next) {
                                const dr_out = next[0] - r;
                                const dc_out = next[1] - c;
                                const [x_out, y_out] = getEdgeCoords(dr_out * -1, dc_out * -1);
                                const delay = i * pulseDelayStep;
                                const animStyle = `animation: laser-wave-pulse ${pulseSpeed} ease-in-out infinite; animation-delay: ${delay}s;`;
                                svgHTML = `<line x1="50%" y1="50%" x2="${x_out}" y2="${y_out}" stroke="${hex}" stroke-width="15" stroke-linecap="round" style="${animStyle}" />`;
                            } else if (prev) {
                                const dr_in = r - prev[0];
                                const dc_in = c - prev[1];
                                const isHit = !next;
                                const dr_out = next ? (next[0] - r) : 0;
                                const dc_out = next ? (next[1] - c) : 0;

                                const isDiagonalIn = dr_in !== 0 && dc_in !== 0;
                                const isHorizontalOut = dr_out === 0 && dc_out !== 0;
                                const isHorizontalIn = dr_in === 0 && dc_in !== 0;
                                const isDiagonalOut = dr_out !== 0 && dc_out !== 0;

                                const isWallReflect_In = isDiagonalIn && isHorizontalOut;
                                const isWallReflect_Out = isHorizontalIn && isDiagonalOut;

                                const isReflection = next && (dr_in !== dr_out || dc_in !== dc_out) && !isWallReflect_In && !isWallReflect_Out;
                                const isPassthrough = next && !isReflection && !isWallReflect_In && !isWallReflect_Out;

                                const [x_in, y_in] = getEdgeCoords(dr_in, dc_in);

                                if (isWallReflect_In) {
                                    const [x_out, y_out] = getEdgeCoords(dr_in * -1, dc_in * -1);
                                    const delay = i * pulseDelayStep;
                                    const animStyle = `animation: laser-wave-pulse ${pulseSpeed} ease-in-out infinite; animation-delay: ${delay}s;`;
                                    svgHTML = `<line x1="${x_in}" y1="${y_in}" x2="${x_out}" y2="${y_out}" stroke="${hex}" stroke-width="15" stroke-linecap="round" style="${animStyle}" />`;
                                } else if (isWallReflect_Out) {
                                    const [x_out, y_out] = getEdgeCoords(dr_out * -1, dc_out * -1);
                                    const [x_in_new, y_in_new] = getEdgeCoords(dr_out, dc_out);
                                    const delay = i * pulseDelayStep;
                                    const animStyle = `animation: laser-wave-pulse ${pulseSpeed} ease-in-out infinite; animation-delay: ${delay}s;`;
                                    svgHTML = `<line x1="${x_in_new}" y1="${y_in_new}" x2="${x_out}" y2="${y_out}" stroke="${hex}" stroke-width="15" stroke-linecap="round" style="${animStyle}" />`;
                                }
                                else if (isPassthrough) {
                                    const [x_out, y_out] = getEdgeCoords(dr_out * -1, dc_out * -1);
                                    const delay = i * pulseDelayStep;
                                    const animStyle = `animation: laser-wave-pulse ${pulseSpeed} ease-in-out infinite; animation-delay: ${delay}s;`;
                                    svgHTML = `<line x1="${x_in}" y1="${y_in}" x2="${x_out}" y2="${y_out}" stroke="${hex}" stroke-width="15" stroke-linecap="round" style="${animStyle}" />`;
                                } else if (isReflection) {
                                    const [x_out, y_out] = getEdgeCoords(dr_out * -1, dc_out * -1);
                                    const delay = i * pulseDelayStep;
                                    const animStyle = `animation: laser-wave-pulse ${pulseSpeed} ease-in-out infinite; animation-delay: ${delay}s;`;
                                    svgHTML = `<line x1="${x_in}" y1="${y_in}" x2="50%" y2="50%" stroke="${hex}" stroke-width="15" stroke-linecap="round" style="${animStyle}" />` +
                                            `<line x1="50%" y1="50%" x2="${x_out}" y2="${y_out}" stroke="${hex}" stroke-width="15" stroke-linecap="round" style="${animStyle}" />`;
                                } else if (isHit) {
                                    const delay = i * pulseDelayStep;
                                    const animStyle = `animation: laser-wave-pulse ${pulseSpeed} ease-in-out infinite; animation-delay: ${delay}s;`;
                                    svgHTML = `<line x1="${x_in}" y1="${y_in}" x2="50%" y2="50%" stroke="${hex}" stroke-width="15" stroke-linecap="round" style="${animStyle}" />`;
                                }
                            }

                            const svg = document.createElement('div');
                            svg.className = 'laser-beam-svg';
                            svg.dataset.laserStep = i;
                            svg.innerHTML = `<svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none">${svgHTML}</svg>`;
                            cell.appendChild(svg);
                        }
                    }
                    i++;
                }, 120);
            }
        };

        // ==========================================
        // 7. EVENT HANDLERS
        // ==========================================
        const Handlers = {
            init: () => {
                DOM.$('#save-profile-btn').onclick = () => API.saveProfile(DOM.$('#profile-display-name').value, DOM.$('#profile-color-select').value);
                
                // --- Lobby View (Main Menu) Handlers ---
                DOM.$('#multi-player-btn').onclick = () => {
                    UIManager.show('lobbyList');
                    API.presence.start(); 
                    API.lobby.listenToList(); 
                };
                DOM.$('#edit-name-btn').onclick = () => {
                    DOM.lobbyNameDisplay.classList.add('hidden');
                    DOM.lobbyNameEdit.classList.remove('hidden');
                    DOM.$('#lobby-name-input').value = State.currentUser.profile.displayName;
                    DOM.$('#lobby-name-input').focus();
                };
                DOM.$('#cancel-name-btn').onclick = () => {
                    DOM.lobbyNameDisplay.classList.remove('hidden');
                    DOM.lobbyNameEdit.classList.add('hidden');
                };
                DOM.$('#save-name-btn').onclick = () => {
                    const newName = DOM.$('#lobby-name-input').value;
                    if (newName && newName !== State.currentUser.profile.displayName) {
                        API.saveProfile(newName, State.currentUser.profile.preferredColor);
                        UIManager.toast("Name updated!");
                    }
                    DOM.lobbyNameDisplay.classList.remove('hidden');
                    DOM.lobbyNameEdit.classList.add('hidden');
                };

                // MODIFIED: To be async
                DOM.$('#show-create-lobby-btn').onclick = async () => {
                    const defaultName = `${State.currentUser.profile.displayName}'s Game`;
                    const defaultEnergy = 10;
                    const defaultColor = State.currentUser.profile.preferredColor;
                    
                    // Await creation so we are immediately put in the lobby
                    await API.lobby.create(defaultName, defaultEnergy, defaultColor);
                };

                // --- Invite Handler (Event Delegation) ---
                DOM.$('#lobby-list-view').onclick = (e) => {
                    const btn = e.target.closest('.invite-btn');
                    if (btn && !btn.disabled) {
                        const { uid, name } = btn.dataset;
                        Handlers.sendInvite(uid, name);
                    }
                };
                DOM.$('#waiting-room-view').onclick = (e) => {
                    const btn = e.target.closest('.invite-btn');
                    if (btn && !btn.disabled) {
                        const { uid, name } = btn.dataset;
                        Handlers.sendInvite(uid, name);
                    }
                };
                
                // --- Waiting Room & Modal ---
                DOM.$('#leave-lobby-btn').onclick = API.lobby.leave;
                DOM.$('#back-to-main-menu-btn').onclick = () => {
                    UIManager.show('lobby');
                    API.presence.stop(); 
                    API.lobby.stopListeningToList();
                };
                DOM.$('#p1-ready-btn').onclick = API.game.toggleReady;
                DOM.$('#p2-ready-btn').onclick = API.game.toggleReady;
                DOM.$('#new-game-btn').onclick = () => { 
                    DOM.views.modal.classList.add('hidden'); 
                    API.lobby.leave(); // This already sends user to 'lobbyList'
                    // Manually trigger a refresh after a short delay
                    setTimeout(() => {
                        const refreshBtn = DOM.$('#refresh-lobbies-btn');
                        if (refreshBtn) refreshBtn.click();
                    }, 100); 
                };

                // --- Game Actions ---
                DOM.$('#place-pylon-btn').onclick = () => { State.currentAction = 'place-pylon'; UIManager.renderBoard(); };
                DOM.$('#place-mirror-btn').onclick = () => { State.currentAction = 'place-mirror'; UIManager.renderBoard(); };
                DOM.$('#move-nexus-btn').onclick = () => {
                    if (State.currentAction === 'move-nexus-target') {
                        State.currentAction = null;
                        State.selectedLocation = null;
                    } else {
                        State.currentAction = 'move-nexus-target';
                        State.selectedLocation = State.game.players[State.playerIndex].nexusLocation;
                    }
                    UIManager.renderGame(); // Re-render board and controls
                };

                // This button is now for CONFIRMING placements
                DOM.$('#attack-btn').onclick = () => {
                    const hasBuildingPreviews = State.previewBuildings.length > 0;
                    const hasNexusPreview = !!State.previewNexusLocation;

                    if (hasBuildingPreviews || hasNexusPreview) {
                        // Pass both previews to the API function
                        API.game.confirmBuyMovePhase(State.previewBuildings, State.previewNexusLocation);
                    } else {
                        // No previews, just move to attack phase
                        API.game.endPhase();
                    }
                };

                DOM.$('#end-turn-btn').onclick = () => {
                    API.game.commitAndEndTurn(State.previewBuildings, State.previewNexusLocation);
                };

                DOM.$('#undo-action-btn').onclick = () => {
                    State.previewBuildings = [];
                    State.previewCost = 0;
                    State.previewNexusLocation = null;
                    UIManager.renderGame(); // Re-render everything
                };

                DOM.$$('.mirror-rotate-btn').forEach(btn => {
                    btn.onclick = () => {
                        const orientation = btn.dataset.orientation;
                        State.currentMirrorOrientation = orientation;
                        DOM.$('#mirror-orientation-display').textContent = orientation;
                        
                        // Check if last preview building is a mirror
                        if (State.currentAction === 'place-mirror' && State.previewBuildings.length > 0) {
                            const lastBuilding = State.previewBuildings[State.previewBuildings.length - 1];
                            if (lastBuilding.type === 'mirror') {
                                // Update its orientation live
                                lastBuilding.orientation = orientation;
                                UIManager.renderBoard(); // Just re-render the board to show change
                            }
                        }
                    };
                });
                
                DOM.$$('button[data-dir]').forEach(btn => {
                    btn.onclick = () => {
                        const dir = CONSTANTS.DIRECTIONS[btn.dataset.dir];
                        API.game.attack(dir[0], dir[1]);
                    };
                });
                DOM.$('#skip-attack-btn').onclick = API.game.cancelAttack;
            },
            
            // NEW: Handler for sending invites
            sendInvite: async (toUid, toName) => {
                try {
                    let gameId = State.gameId;

                    // If not in a lobby, create one
                    if (!gameId) {
                        UIManager.toast("Creating new lobby...");
                        const defaultName = `${State.currentUser.profile.displayName}'s Invite Lobby`;
                        gameId = await API.lobby.create(defaultName, 10, State.currentUser.profile.preferredColor);
                        if (!gameId) throw new Error("Lobby creation failed.");
                        // API.lobby.create already starts listening, which will set State.game
                    }
                    
                    // We need to wait for State.game to be populated by the listener
                    // A simple delay/check, or trust the create() call
                    if (!State.game) {
                        // Wait a moment for listener to fire
                        await new Promise(r => setTimeout(r, 500)); 
                        if (!State.game) throw new Error("Game state not ready.");
                    }

                    // Now send the invite
                    await API.presence.sendInvite(toUid, toName, gameId);

                } catch (err) {
                    console.error("Invite Error:", err);
                    UIManager.showError(err.message);
                }
            },

            boardClick: (r, c) => {
                const act = State.currentAction;
                const isMine = (c >= (State.playerIndex === 0 ? 0 : 5) && c < (State.playerIndex === 0 ? 5 : 10));
                
                // Check for any existing unit (real or preview)
                const realUnit = GameLogic.getUnitAt(r,c, State.game);
                const previewUnit = State.previewBuildings.find(b => b.location[0] === r && b.location[1] === c);
                const previewNexus = State.previewNexusLocation && State.previewNexusLocation[0] === r && State.previewNexusLocation[1] === c;
                const isOccupied = realUnit || previewUnit || previewNexus;

                // Req #1: Nexus setup just updates the preview
                if(act === 'setup' && isMine && !realUnit) { 
                    State.previewNexus = [r,c];
                    UIManager.renderBoard();
                    UIManager.renderControls(0); // Pass 0, budget not relevant
                    return; // Stop here
                }
                
                // --- New Building Placement Logic (Req #2, #4, #5) ---
                const budget = (State.game.turnBudget || 0) - State.previewCost;
                
                if((act === 'place-pylon' || act === 'place-mirror') && isMine && !isOccupied) {
                    if (budget < 1) {
                        UIManager.toast("Out of budget for this turn.");
                        return;
                    }
                    if (State.game.energyPool - State.previewCost < 1) {
                        UIManager.toast("Not enough energy in pool.");
                        return;
                    }
                    
                    const type = act.split('-')[1];
                    const newPreviewBuilding = {
                        type: type,
                        location: [r,c]
                    };
                    
                    if (type === 'mirror') {
                        newPreviewBuilding.orientation = State.currentMirrorOrientation;
                    }
                    
                    State.previewBuildings.push(newPreviewBuilding);
                    State.previewCost += 1;
                    
                    // Re-render board and controls (Req #4: allows placing multiples)
                    UIManager.renderGame();
                    return; // Stop here
                }
                
                if(act === 'move-nexus-target') {
                    if(GameLogic.isValidNexusMove(State.selectedLocation, [r,c], State.playerIndex, State.game)) {
                        State.previewNexusLocation = [r,c]; // Set preview instead of API call
                        State.currentAction = null;
                        State.selectedLocation = null;
                    }
                    // Don't return, allow re-render
                }
                
                // Re-render board/controls if no specific action was taken
                // This is good for deselecting, etc.
                UIManager.renderGame();
            }
        };

        // ==========================================
        // 8. INIT
        // ==========================================
        window.addEventListener('load', () => {
            API.init();
            Handlers.init();
        });
    </script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .font-sci-mono {
            font-family: 'Orbitron', 'Courier New', monospace; /* Fallback to monospace */
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Orbitron:wght@400;700&display=swap');

        .cell {
            box-shadow: inset 0 0 2px rgba(167, 139, 250, 0.2);
        }

        /* Laser animation */
        @keyframes laser-wave-pulse {
            0%, 100% { stroke-width: 15; opacity: 1; }
            50% { stroke-width: 25; opacity: 0.7; }
        }
        @keyframes beam-fade {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
        .laser-beam-svg {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            filter: drop-shadow(0 0 4px var(--laser-color));
        }

        /* Custom scrollbar */
        #game-log::-webkit-scrollbar,
        #lobby-list-container::-webkit-scrollbar,
        .online-players-list::-webkit-scrollbar {
            width: 8px;
        }
        #game-log::-webkit-scrollbar-track,
        #lobby-list-container::-webkit-scrollbar-track,
        .online-players-list::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        #game-log::-webkit-scrollbar-thumb,
        #lobby-list-container::-webkit-scrollbar-thumb,
        .online-players-list::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-600 */
            border-radius: 4px;
        }
        #game-log::-webkit-scrollbar-thumb:hover,
        #lobby-list-container::-webkit-scrollbar-thumb:hover,
        .online-players-list::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200 min-h-screen p-4 md:p-8 flex items-center justify-center">

    <div id="app" class="w-full max-w-7xl mx-auto">

        <div id="profile-view" class="hidden w-full max-w-md mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Welcome!</h1>
            <p class="text-center text-gray-300 mb-4">Please create your profile to play.</p>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Display Name</label>
                    <input id="profile-display-name" type="text" placeholder="Enter your name" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:border-indigo-500 outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Preferred Color</label>
                    <select id="profile-color-select" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:border-indigo-500 outline-none"></select>
                </div>
                <button id="save-profile-btn" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg transition-all shadow-lg">Save Profile</button>
            </div>
        </div>

        <div id="lobby-view" class="hidden w-full max-w-md mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Zero-Sum Defense</h1>
            
            <div class="mb-4 p-3 bg-gray-900 rounded-lg">
                <p class="text-sm text-gray-400">Welcome,</p>
                
                <div id="lobby-user-name-display" class="flex justify-between items-center">
                    <p id="user-display-name-display" class="font-mono text-lg break-all">...</p>
                    <button id="edit-name-btn" class="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded-md">Edit</button>
                </div>

                <div id="lobby-user-name-edit" class="hidden space-y-2">
                    <input id="lobby-name-input" type="text" class="w-full bg-gray-700 text-white p-2 rounded-lg border border-gray-600 outline-none">
                    <div class="flex gap-2">
                        <button id="cancel-name-btn" class="w-1/2 text-xs bg-gray-600 hover:bg-gray-500 px-2 py-1 rounded-md">Cancel</button>
                        <button id="save-name-btn" class="w-1/2 text-xs bg-green-600 hover:bg-green-500 px-2 py-1 rounded-md">Save</button>
                    </div>
                </div>

                <p class="text-xs text-gray-500 mt-1">User ID: <span id="user-id-display" class="font-mono break-all">Loading...</span></p>
            </div>

            <div class="space-y-4">
                <button id="single-player-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg opacity-50 cursor-not-allowed" disabled>Singleplayer (Soon)</button>
                <button id="multi-player-btn" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg shadow-lg">Multiplayer</button>
            </div>
        </div>
        
        <div id="lobby-list-view" class="hidden w-full max-w-4xl mx-auto flex flex-col md:flex-row gap-4">
            <div class="flex-grow p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
                <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Open Lobbies</h1>
                <div class="flex justify-between mb-4">
                    <button id="back-to-main-menu-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg">&larr; Main Menu</button>
                </div>
                <div id="lobby-list-container" class="space-y-3 max-h-96 overflow-y-auto p-2 bg-gray-900/50 rounded-lg"></div>
                <button id="show-create-lobby-btn" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg mt-6">+ Create New Lobby</button>
            </div>

            <div class="w-full md:w-64 lg:w-80 flex-shrink-0 p-4 bg-gray-900/80 rounded-lg border border-gray-700">
                <h3 class="text-sm font-bold text-gray-400 uppercase tracking-widest mb-3 border-b border-gray-700 pb-2">Looking For Game</h3>
                <div class="online-players-list space-y-1 max-h-96 overflow-y-auto text-sm">
                    <p class="text-gray-500 italic">Scanning...</p>
                </div>
            </div>
        </div>

        <div id="waiting-room-view" class="hidden w-full max-w-4xl mx-auto flex flex-col md:flex-row gap-4">
            <div class="flex-grow p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
                <div id="host-settings-panel" class="hidden mb-6 space-y-3 p-4 bg-gray-900/50 rounded-lg border border-indigo-500/30">
                    <h3 class="text-lg font-bold text-center font-sci-mono text-cyan-400">Host Settings</h3>
                    <div>
                        <label class="block text-sm font-medium text-gray-400 mb-1">Lobby Name</label>
                        <input id="waiting-lobby-name-input" type="text" class="w-full bg-gray-700 text-white p-2 rounded-lg border border-gray-600 outline-none disabled:opacity-50" disabled>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-400 mb-1">Starting Energy</label>
                        <select id="waiting-energy-pool-select" class="w-full bg-gray-700 text-white p-2 rounded-lg border border-gray-600 outline-none disabled:opacity-50" disabled>
                            <option value="10">Standard (10)</option>
                            <option value="20">High (20)</option>
                            <option value="5">Low (5)</option>
                        </select>
                    </div>
                </div>
                
                <h2 class="text-2xl font-bold text-center mb-2 font-sci-mono text-cyan-400">Lobby</h2>
                <h3 id="waiting-lobby-name" class="text-xl text-center text-gray-300 mb-6">...</h3>
                
                <div class="grid grid-cols-2 gap-4 text-center mb-6">
                    <div class="p-4 bg-gray-900/50 rounded-lg relative group">
                        <p class="text-xs text-gray-400 mb-1">HOST</p>
                        <p id="p1-name" class="text-lg font-bold truncate">...</p>
                        <select id="p1-color-select" class="mt-2 bg-gray-800 text-xs text-white p-1 rounded border border-gray-600 w-full disabled:opacity-50" disabled></select>
                        <div id="p1-ready-indicator" class="mt-2 text-xs font-bold text-red-500 uppercase tracking-widest">Not Ready</div>
                        <button id="p1-ready-btn" class="hidden mt-2 w-full py-1 px-2 text-xs font-bold rounded bg-gray-700 hover:bg-gray-600 transition-all">Toggle Ready</button>
                    </div>

                    <div class="p-4 bg-gray-900/50 rounded-lg relative group">
                        <p class="text-xs text-gray-400 mb-1">CHALLENGER</p>
                        <p id="p2-name" class="text-lg font-bold truncate text-gray-500">Empty</p>
                        <select id="p2-color-select" class="hidden mt-2 bg-gray-800 text-xs text-white p-1 rounded border border-gray-600 w-full"></select>
                        <div id="p2-ready-indicator" class="hidden mt-2 text-xs font-bold text-red-500 uppercase tracking-widest">Not Ready</div>
                        <button id="p2-ready-btn" class="hidden mt-2 w-full py-1 px-2 text-xs font-bold rounded bg-gray-700 hover:bg-gray-600 transition-all">Toggle Ready</button>
                        <button id="kick-p2-btn" class="hidden mt-2 w-full py-1 px-2 text-xs font-bold rounded bg-red-800 hover:bg-red-700 text-white transition-all">Kick Player</button>
                    </div>
                </div>
                
                <button id="start-game-btn" class="w-full bg-gray-600 opacity-50 cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg mb-3" disabled>Waiting...</button>
                <button id="leave-lobby-btn" class="w-full bg-red-900/80 hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg transition-all shadow-lg">Leave Lobby</button>
            </div>

            <div class="w-full md:w-64 lg:w-80 flex-shrink-0 p-4 bg-gray-900/80 rounded-lg border border-gray-700">
                <h3 class="text-sm font-bold text-gray-400 uppercase tracking-widest mb-3 border-b border-gray-700 pb-2">Looking For Game</h3>
                <div class="online-players-list space-y-1 max-h-96 overflow-y-auto text-sm">
                    <p class="text-gray-500 italic">Scanning...</p>
                </div>
            </div>
        </div>

        <div id="game-view" class="hidden w-full">
            <div class="mb-4 p-4 bg-gray-800/50 rounded-lg shadow-lg backdrop-blur-md border border-indigo-500/30 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 text-center">
                <div class="font-sci-mono"><span class="text-xs text-gray-400 block">Game ID</span><span id="game-id-display" class="text-sm break-all">...</span></div>
                <div class="font-sci-mono"><span id="player-hud-label" class="text-xs text-gray-400 block">You Are</span><span id="player-hud-info" class="text-lg font-bold">...</span></div>
                <div class="font-sci-mono"><span id="opponent-hud-label" class="text-xs text-gray-400 block">Opponent</span><span id="opponent-hud-info" class="text-lg font-bold">...</span></div>
                <div class="font-sci-mono"><span class="text-xs text-gray-400 block">Phase</span><span id="current-phase" class="text-lg font-bold">...</span></div>
                <div class="font-sci-mono"><span class="text-xs text-gray-400 block">Energy Pool</span><span id="energy-pool" class="text-lg font-bold text-cyan-400">10</span></div>
                <div class="font-sci-mono"><span class="text-xs text-gray-400 block">Your Budget</span><span id="player-budget" class="text-lg font-bold text-green-400">$0</span></div>
            </div>

            <div class="flex flex-col lg:flex-row gap-4">
                <div class="flex-grow">
                    <div id="game-board" class="grid grid-cols-10 gap-1 bg-gray-900/50 p-2 rounded-lg border border-indigo-500/30"></div>
                </div>

                <div class="w-full lg:w-80 xl:w-96 flex-shrink-0 flex flex-col gap-4">
                    <div id="control-panel" class="min-h-96 p-4 bg-gray-800/50 rounded-lg shadow-lg backdrop-blur-md border border-indigo-500/30">
                        <h3 class="text-xl font-bold mb-4 text-center font-sci-mono text-cyan-400">CONTROLS</h3>
                        
                        <div id="setup-controls" class="hidden text-center">
                            <p class="text-lg text-yellow-300 animate-pulse">Select a cell and confirm your Nexus location.</p>
                            <button id="confirm-nexus-btn" class="w-full mt-4 bg-green-600 hover:bg-green-500 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg transition-all text-lg" disabled>Confirm Placement</button>
                        </div>

                        <div id="buy-move-controls" class="hidden space-y-3">
                            <div class="grid grid-cols-2 gap-2">
                                <button id="place-pylon-btn" class="w-full bg-cyan-700 hover:bg-cyan-600 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg">Pylon (1E)</button>
                                <button id="place-mirror-btn" class="w-full bg-purple-700 hover:bg-purple-600 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg">Mirror (1E)</button>
                            </div>
                            
                            <div id="mirror-rotation-controls" class="hidden p-2 bg-gray-900/50 rounded-lg">
                                <p class="text-center text-xs text-gray-400 mb-2">Mirror Orientation: <span id="mirror-orientation-display" class="font-bold text-purple-300">N</span></p>
                                <div class="grid grid-cols-3 gap-1 w-32 mx-auto">
                                    <button data-orientation="NW" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">NW</button>
                                    <button data-orientation="N" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">N</button>
                                    <button data-orientation="NE" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">NE</button>
                                    <button data-orientation="W" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">W</button>
                                    <div class="aspect-square"></div>
                                    <button data-orientation="E" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">E</button>
                                    <button data-orientation="SW" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">SW</button>
                                    <button data-orientation="S" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">S</button>
                                    <button data-orientation="SE" class="mirror-rotate-btn aspect-square bg-purple-900/70 hover:bg-purple-800 rounded-lg text-xs">SE</button>
                                </div>
                            </div>
                            
                            <button id="move-nexus-btn" class="w-full bg-yellow-600 hover:bg-yellow-500 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg">Move Nexus</button>
                            
                            <hr id="buy-move-separator" class="border-gray-600 my-3">
                            
                            <button id="undo-action-btn" class="w-full bg-yellow-700 hover:bg-yellow-600 disabled:bg-gray-600 text-white font-bold p-2 rounded-lg text-sm">Undo</button>
                            
                            <div class="flex gap-2">
                                <button id="end-turn-btn" class="w-1/3 bg-green-600 hover:bg-green-500 text-white font-bold p-3 rounded-lg text-base">End Turn</button>
                                <button id="attack-btn" class="w-2/3 bg-red-800 hover:bg-red-700 text-white font-bold p-3 rounded-lg text-lg">Attack</button>
                            </div>
                        </div>

                        <div id="attack-controls" class="hidden">
                            <p class="text-center mb-3 text-lg text-red-400 animate-pulse">Select Attack Vector</p>
                            <div class="grid grid-cols-3 gap-2 w-48 mx-auto">
                                <button id="attack-nw-btn" data-dir="NW" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">NW</button>
                                <button id="attack-n-btn" data-dir="N" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">N</button>
                                <button id="attack-ne-btn" data-dir="NE" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">NE</button>
                                <button id="attack-w-btn" data-dir="W" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">W</button>
                                <div class="aspect-square flex items-center justify-center text-red-400">+</div>
                                <button id="attack-e-btn" data-dir="E" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">E</button>
                                <button id="attack-sw-btn" data-dir="SW" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">SW</button>
                                <button id="attack-s-btn" data-dir="S" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">S</button>
                                <button id="attack-se-btn" data-dir="SE" class="aspect-square bg-red-800 hover:bg-red-700 rounded-lg font-bold">SE</button>
                            </div>
                            <hr class="border-gray-600 my-3">
                            <button id="skip-attack-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold p-3 rounded-lg text-lg">Cancel</button>
                        </div>

                        <div id="waiting-controls" class="hidden text-center">
                            <p class="text-lg text-gray-400 animate-pulse">Waiting for opponent...</p>
                        </div>
                    </div>

                    <div class="flex-grow p-4 bg-gray-800/50 rounded-lg shadow-lg backdrop-blur-md border border-indigo-500/30 min-h-[200px] lg:min-h-0">
                        <h3 class="text-xl font-bold mb-4 text-center font-sci-mono text-cyan-400">EVENT LOG</h3>
                        <div id="game-log" class="h-48 lg:h-full lg:max-h-96 overflow-y-auto space-y-2 pr-2 font-mono"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="modal-view" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
            <div class="bg-gray-800 p-8 rounded-lg shadow-xl border border-indigo-500/50 max-w-lg w-full text-center">
                <div id="modal-message" class="text-2xl mb-6">...</div>
                <button id="new-game-btn" class="hidden bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg text-lg transition-all">Back to Lobby</button>
            </div>
        </div>

    </div>
</body>
</html>